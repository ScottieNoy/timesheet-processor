/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/minimatch";
exports.ids = ["vendor-chunks/minimatch"];
exports.modules = {

/***/ "(rsc)/./node_modules/minimatch/minimatch.js":
/*!*********************************************!*\
  !*** ./node_modules/minimatch/minimatch.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = minimatch;\nminimatch.Minimatch = Minimatch;\nvar path = function() {\n    try {\n        return __webpack_require__(/*! path */ \"path\");\n    } catch (e) {}\n}() || {\n    sep: \"/\"\n};\nminimatch.sep = path.sep;\nvar GLOBSTAR = minimatch.GLOBSTAR = Minimatch.GLOBSTAR = {};\nvar expand = __webpack_require__(/*! brace-expansion */ \"(rsc)/./node_modules/brace-expansion/index.js\");\nvar plTypes = {\n    \"!\": {\n        open: \"(?:(?!(?:\",\n        close: \"))[^/]*?)\"\n    },\n    \"?\": {\n        open: \"(?:\",\n        close: \")?\"\n    },\n    \"+\": {\n        open: \"(?:\",\n        close: \")+\"\n    },\n    \"*\": {\n        open: \"(?:\",\n        close: \")*\"\n    },\n    \"@\": {\n        open: \"(?:\",\n        close: \")\"\n    }\n};\n// any single thing other than /\n// don't need to escape / when using new RegExp()\nvar qmark = \"[^/]\";\n// * => any number of characters\nvar star = qmark + \"*?\";\n// ** when dots are allowed.  Anything goes, except .. and .\n// not (^ or / followed by one or two dots followed by $ or /),\n// followed by anything, any number of times.\nvar twoStarDot = \"(?:(?!(?:\\\\/|^)(?:\\\\.{1,2})($|\\\\/)).)*?\";\n// not a ^ or / followed by a dot,\n// followed by anything, any number of times.\nvar twoStarNoDot = \"(?:(?!(?:\\\\/|^)\\\\.).)*?\";\n// characters that need to be escaped in RegExp.\nvar reSpecials = charSet(\"().*{}+?[]^$\\\\!\");\n// \"abc\" -> { a:true, b:true, c:true }\nfunction charSet(s) {\n    return s.split(\"\").reduce(function(set, c) {\n        set[c] = true;\n        return set;\n    }, {});\n}\n// normalizes slashes.\nvar slashSplit = /\\/+/;\nminimatch.filter = filter;\nfunction filter(pattern, options) {\n    options = options || {};\n    return function(p, i, list) {\n        return minimatch(p, pattern, options);\n    };\n}\nfunction ext(a, b) {\n    b = b || {};\n    var t = {};\n    Object.keys(a).forEach(function(k) {\n        t[k] = a[k];\n    });\n    Object.keys(b).forEach(function(k) {\n        t[k] = b[k];\n    });\n    return t;\n}\nminimatch.defaults = function(def) {\n    if (!def || typeof def !== \"object\" || !Object.keys(def).length) {\n        return minimatch;\n    }\n    var orig = minimatch;\n    var m = function minimatch(p, pattern, options) {\n        return orig(p, pattern, ext(def, options));\n    };\n    m.Minimatch = function Minimatch(pattern, options) {\n        return new orig.Minimatch(pattern, ext(def, options));\n    };\n    m.Minimatch.defaults = function defaults(options) {\n        return orig.defaults(ext(def, options)).Minimatch;\n    };\n    m.filter = function filter(pattern, options) {\n        return orig.filter(pattern, ext(def, options));\n    };\n    m.defaults = function defaults(options) {\n        return orig.defaults(ext(def, options));\n    };\n    m.makeRe = function makeRe(pattern, options) {\n        return orig.makeRe(pattern, ext(def, options));\n    };\n    m.braceExpand = function braceExpand(pattern, options) {\n        return orig.braceExpand(pattern, ext(def, options));\n    };\n    m.match = function(list, pattern, options) {\n        return orig.match(list, pattern, ext(def, options));\n    };\n    return m;\n};\nMinimatch.defaults = function(def) {\n    return minimatch.defaults(def).Minimatch;\n};\nfunction minimatch(p, pattern, options) {\n    assertValidPattern(pattern);\n    if (!options) options = {};\n    // shortcut: comments match nothing.\n    if (!options.nocomment && pattern.charAt(0) === \"#\") {\n        return false;\n    }\n    return new Minimatch(pattern, options).match(p);\n}\nfunction Minimatch(pattern, options) {\n    if (!(this instanceof Minimatch)) {\n        return new Minimatch(pattern, options);\n    }\n    assertValidPattern(pattern);\n    if (!options) options = {};\n    pattern = pattern.trim();\n    // windows support: need to use /, not \\\n    if (!options.allowWindowsEscape && path.sep !== \"/\") {\n        pattern = pattern.split(path.sep).join(\"/\");\n    }\n    this.options = options;\n    this.set = [];\n    this.pattern = pattern;\n    this.regexp = null;\n    this.negate = false;\n    this.comment = false;\n    this.empty = false;\n    this.partial = !!options.partial;\n    // make the set of regexps etc.\n    this.make();\n}\nMinimatch.prototype.debug = function() {};\nMinimatch.prototype.make = make;\nfunction make() {\n    var pattern = this.pattern;\n    var options = this.options;\n    // empty patterns and comments match nothing.\n    if (!options.nocomment && pattern.charAt(0) === \"#\") {\n        this.comment = true;\n        return;\n    }\n    if (!pattern) {\n        this.empty = true;\n        return;\n    }\n    // step 1: figure out negation, etc.\n    this.parseNegate();\n    // step 2: expand braces\n    var set = this.globSet = this.braceExpand();\n    if (options.debug) this.debug = function debug() {\n        console.error.apply(console, arguments);\n    };\n    this.debug(this.pattern, set);\n    // step 3: now we have a set, so turn each one into a series of path-portion\n    // matching patterns.\n    // These will be regexps, except in the case of \"**\", which is\n    // set to the GLOBSTAR object for globstar behavior,\n    // and will not contain any / characters\n    set = this.globParts = set.map(function(s) {\n        return s.split(slashSplit);\n    });\n    this.debug(this.pattern, set);\n    // glob --> regexps\n    set = set.map(function(s, si, set) {\n        return s.map(this.parse, this);\n    }, this);\n    this.debug(this.pattern, set);\n    // filter out everything that didn't compile properly.\n    set = set.filter(function(s) {\n        return s.indexOf(false) === -1;\n    });\n    this.debug(this.pattern, set);\n    this.set = set;\n}\nMinimatch.prototype.parseNegate = parseNegate;\nfunction parseNegate() {\n    var pattern = this.pattern;\n    var negate = false;\n    var options = this.options;\n    var negateOffset = 0;\n    if (options.nonegate) return;\n    for(var i = 0, l = pattern.length; i < l && pattern.charAt(i) === \"!\"; i++){\n        negate = !negate;\n        negateOffset++;\n    }\n    if (negateOffset) this.pattern = pattern.substr(negateOffset);\n    this.negate = negate;\n}\n// Brace expansion:\n// a{b,c}d -> abd acd\n// a{b,}c -> abc ac\n// a{0..3}d -> a0d a1d a2d a3d\n// a{b,c{d,e}f}g -> abg acdfg acefg\n// a{b,c}d{e,f}g -> abdeg acdeg abdeg abdfg\n//\n// Invalid sets are not expanded.\n// a{2..}b -> a{2..}b\n// a{b}c -> a{b}c\nminimatch.braceExpand = function(pattern, options) {\n    return braceExpand(pattern, options);\n};\nMinimatch.prototype.braceExpand = braceExpand;\nfunction braceExpand(pattern, options) {\n    if (!options) {\n        if (this instanceof Minimatch) {\n            options = this.options;\n        } else {\n            options = {};\n        }\n    }\n    pattern = typeof pattern === \"undefined\" ? this.pattern : pattern;\n    assertValidPattern(pattern);\n    // Thanks to Yeting Li <https://github.com/yetingli> for\n    // improving this regexp to avoid a ReDOS vulnerability.\n    if (options.nobrace || !/\\{(?:(?!\\{).)*\\}/.test(pattern)) {\n        // shortcut. no need to expand.\n        return [\n            pattern\n        ];\n    }\n    return expand(pattern);\n}\nvar MAX_PATTERN_LENGTH = 1024 * 64;\nvar assertValidPattern = function(pattern) {\n    if (typeof pattern !== \"string\") {\n        throw new TypeError(\"invalid pattern\");\n    }\n    if (pattern.length > MAX_PATTERN_LENGTH) {\n        throw new TypeError(\"pattern is too long\");\n    }\n};\n// parse a component of the expanded set.\n// At this point, no pattern may contain \"/\" in it\n// so we're going to return a 2d array, where each entry is the full\n// pattern, split on '/', and then turned into a regular expression.\n// A regexp is made at the end which joins each array with an\n// escaped /, and another full one which joins each regexp with |.\n//\n// Following the lead of Bash 4.1, note that \"**\" only has special meaning\n// when it is the *only* thing in a path portion.  Otherwise, any series\n// of * is equivalent to a single *.  Globstar behavior is enabled by\n// default, and can be disabled by setting options.noglobstar.\nMinimatch.prototype.parse = parse;\nvar SUBPARSE = {};\nfunction parse(pattern, isSub) {\n    assertValidPattern(pattern);\n    var options = this.options;\n    // shortcuts\n    if (pattern === \"**\") {\n        if (!options.noglobstar) return GLOBSTAR;\n        else pattern = \"*\";\n    }\n    if (pattern === \"\") return \"\";\n    var re = \"\";\n    var hasMagic = !!options.nocase;\n    var escaping = false;\n    // ? => one single character\n    var patternListStack = [];\n    var negativeLists = [];\n    var stateChar;\n    var inClass = false;\n    var reClassStart = -1;\n    var classStart = -1;\n    // . and .. never match anything that doesn't start with .,\n    // even when options.dot is set.\n    var patternStart = pattern.charAt(0) === \".\" ? \"\" // anything\n     : options.dot ? \"(?!(?:^|\\\\/)\\\\.{1,2}(?:$|\\\\/))\" : \"(?!\\\\.)\";\n    var self = this;\n    function clearStateChar() {\n        if (stateChar) {\n            // we had some state-tracking character\n            // that wasn't consumed by this pass.\n            switch(stateChar){\n                case \"*\":\n                    re += star;\n                    hasMagic = true;\n                    break;\n                case \"?\":\n                    re += qmark;\n                    hasMagic = true;\n                    break;\n                default:\n                    re += \"\\\\\" + stateChar;\n                    break;\n            }\n            self.debug(\"clearStateChar %j %j\", stateChar, re);\n            stateChar = false;\n        }\n    }\n    for(var i = 0, len = pattern.length, c; i < len && (c = pattern.charAt(i)); i++){\n        this.debug(\"%s\t%s %s %j\", pattern, i, re, c);\n        // skip over any that are escaped.\n        if (escaping && reSpecials[c]) {\n            re += \"\\\\\" + c;\n            escaping = false;\n            continue;\n        }\n        switch(c){\n            /* istanbul ignore next */ case \"/\":\n                {\n                    // completely not allowed, even escaped.\n                    // Should already be path-split by now.\n                    return false;\n                }\n            case \"\\\\\":\n                clearStateChar();\n                escaping = true;\n                continue;\n            // the various stateChar values\n            // for the \"extglob\" stuff.\n            case \"?\":\n            case \"*\":\n            case \"+\":\n            case \"@\":\n            case \"!\":\n                this.debug(\"%s\t%s %s %j <-- stateChar\", pattern, i, re, c);\n                // all of those are literals inside a class, except that\n                // the glob [!a] means [^a] in regexp\n                if (inClass) {\n                    this.debug(\"  in class\");\n                    if (c === \"!\" && i === classStart + 1) c = \"^\";\n                    re += c;\n                    continue;\n                }\n                // if we already have a stateChar, then it means\n                // that there was something like ** or +? in there.\n                // Handle the stateChar, then proceed with this one.\n                self.debug(\"call clearStateChar %j\", stateChar);\n                clearStateChar();\n                stateChar = c;\n                // if extglob is disabled, then +(asdf|foo) isn't a thing.\n                // just clear the statechar *now*, rather than even diving into\n                // the patternList stuff.\n                if (options.noext) clearStateChar();\n                continue;\n            case \"(\":\n                if (inClass) {\n                    re += \"(\";\n                    continue;\n                }\n                if (!stateChar) {\n                    re += \"\\\\(\";\n                    continue;\n                }\n                patternListStack.push({\n                    type: stateChar,\n                    start: i - 1,\n                    reStart: re.length,\n                    open: plTypes[stateChar].open,\n                    close: plTypes[stateChar].close\n                });\n                // negation is (?:(?!js)[^/]*)\n                re += stateChar === \"!\" ? \"(?:(?!(?:\" : \"(?:\";\n                this.debug(\"plType %j %j\", stateChar, re);\n                stateChar = false;\n                continue;\n            case \")\":\n                if (inClass || !patternListStack.length) {\n                    re += \"\\\\)\";\n                    continue;\n                }\n                clearStateChar();\n                hasMagic = true;\n                var pl = patternListStack.pop();\n                // negation is (?:(?!js)[^/]*)\n                // The others are (?:<pattern>)<type>\n                re += pl.close;\n                if (pl.type === \"!\") {\n                    negativeLists.push(pl);\n                }\n                pl.reEnd = re.length;\n                continue;\n            case \"|\":\n                if (inClass || !patternListStack.length || escaping) {\n                    re += \"\\\\|\";\n                    escaping = false;\n                    continue;\n                }\n                clearStateChar();\n                re += \"|\";\n                continue;\n            // these are mostly the same in regexp and glob\n            case \"[\":\n                // swallow any state-tracking char before the [\n                clearStateChar();\n                if (inClass) {\n                    re += \"\\\\\" + c;\n                    continue;\n                }\n                inClass = true;\n                classStart = i;\n                reClassStart = re.length;\n                re += c;\n                continue;\n            case \"]\":\n                //  a right bracket shall lose its special\n                //  meaning and represent itself in\n                //  a bracket expression if it occurs\n                //  first in the list.  -- POSIX.2 2.8.3.2\n                if (i === classStart + 1 || !inClass) {\n                    re += \"\\\\\" + c;\n                    escaping = false;\n                    continue;\n                }\n                // handle the case where we left a class open.\n                // \"[z-a]\" is valid, equivalent to \"\\[z-a\\]\"\n                // split where the last [ was, make sure we don't have\n                // an invalid re. if so, re-walk the contents of the\n                // would-be class to re-translate any characters that\n                // were passed through as-is\n                // TODO: It would probably be faster to determine this\n                // without a try/catch and a new RegExp, but it's tricky\n                // to do safely.  For now, this is safe and works.\n                var cs = pattern.substring(classStart + 1, i);\n                try {\n                    RegExp(\"[\" + cs + \"]\");\n                } catch (er) {\n                    // not a valid class!\n                    var sp = this.parse(cs, SUBPARSE);\n                    re = re.substr(0, reClassStart) + \"\\\\[\" + sp[0] + \"\\\\]\";\n                    hasMagic = hasMagic || sp[1];\n                    inClass = false;\n                    continue;\n                }\n                // finish up the class.\n                hasMagic = true;\n                inClass = false;\n                re += c;\n                continue;\n            default:\n                // swallow any state char that wasn't consumed\n                clearStateChar();\n                if (escaping) {\n                    // no need\n                    escaping = false;\n                } else if (reSpecials[c] && !(c === \"^\" && inClass)) {\n                    re += \"\\\\\";\n                }\n                re += c;\n        } // switch\n    } // for\n    // handle the case where we left a class open.\n    // \"[abc\" is valid, equivalent to \"\\[abc\"\n    if (inClass) {\n        // split where the last [ was, and escape it\n        // this is a huge pita.  We now have to re-walk\n        // the contents of the would-be class to re-translate\n        // any characters that were passed through as-is\n        cs = pattern.substr(classStart + 1);\n        sp = this.parse(cs, SUBPARSE);\n        re = re.substr(0, reClassStart) + \"\\\\[\" + sp[0];\n        hasMagic = hasMagic || sp[1];\n    }\n    // handle the case where we had a +( thing at the *end*\n    // of the pattern.\n    // each pattern list stack adds 3 chars, and we need to go through\n    // and escape any | chars that were passed through as-is for the regexp.\n    // Go through and escape them, taking care not to double-escape any\n    // | chars that were already escaped.\n    for(pl = patternListStack.pop(); pl; pl = patternListStack.pop()){\n        var tail = re.slice(pl.reStart + pl.open.length);\n        this.debug(\"setting tail\", re, pl);\n        // maybe some even number of \\, then maybe 1 \\, followed by a |\n        tail = tail.replace(/((?:\\\\{2}){0,64})(\\\\?)\\|/g, function(_, $1, $2) {\n            if (!$2) {\n                // the | isn't already escaped, so escape it.\n                $2 = \"\\\\\";\n            }\n            // need to escape all those slashes *again*, without escaping the\n            // one that we need for escaping the | character.  As it works out,\n            // escaping an even number of slashes can be done by simply repeating\n            // it exactly after itself.  That's why this trick works.\n            //\n            // I am sorry that you have to see this.\n            return $1 + $1 + $2 + \"|\";\n        });\n        this.debug(\"tail=%j\\n   %s\", tail, tail, pl, re);\n        var t = pl.type === \"*\" ? star : pl.type === \"?\" ? qmark : \"\\\\\" + pl.type;\n        hasMagic = true;\n        re = re.slice(0, pl.reStart) + t + \"\\\\(\" + tail;\n    }\n    // handle trailing things that only matter at the very end.\n    clearStateChar();\n    if (escaping) {\n        // trailing \\\\\n        re += \"\\\\\\\\\";\n    }\n    // only need to apply the nodot start if the re starts with\n    // something that could conceivably capture a dot\n    var addPatternStart = false;\n    switch(re.charAt(0)){\n        case \"[\":\n        case \".\":\n        case \"(\":\n            addPatternStart = true;\n    }\n    // Hack to work around lack of negative lookbehind in JS\n    // A pattern like: *.!(x).!(y|z) needs to ensure that a name\n    // like 'a.xyz.yz' doesn't match.  So, the first negative\n    // lookahead, has to look ALL the way ahead, to the end of\n    // the pattern.\n    for(var n = negativeLists.length - 1; n > -1; n--){\n        var nl = negativeLists[n];\n        var nlBefore = re.slice(0, nl.reStart);\n        var nlFirst = re.slice(nl.reStart, nl.reEnd - 8);\n        var nlLast = re.slice(nl.reEnd - 8, nl.reEnd);\n        var nlAfter = re.slice(nl.reEnd);\n        nlLast += nlAfter;\n        // Handle nested stuff like *(*.js|!(*.json)), where open parens\n        // mean that we should *not* include the ) in the bit that is considered\n        // \"after\" the negated section.\n        var openParensBefore = nlBefore.split(\"(\").length - 1;\n        var cleanAfter = nlAfter;\n        for(i = 0; i < openParensBefore; i++){\n            cleanAfter = cleanAfter.replace(/\\)[+*?]?/, \"\");\n        }\n        nlAfter = cleanAfter;\n        var dollar = \"\";\n        if (nlAfter === \"\" && isSub !== SUBPARSE) {\n            dollar = \"$\";\n        }\n        var newRe = nlBefore + nlFirst + nlAfter + dollar + nlLast;\n        re = newRe;\n    }\n    // if the re is not \"\" at this point, then we need to make sure\n    // it doesn't match against an empty path part.\n    // Otherwise a/* will match a/, which it should not.\n    if (re !== \"\" && hasMagic) {\n        re = \"(?=.)\" + re;\n    }\n    if (addPatternStart) {\n        re = patternStart + re;\n    }\n    // parsing just a piece of a larger pattern.\n    if (isSub === SUBPARSE) {\n        return [\n            re,\n            hasMagic\n        ];\n    }\n    // skip the regexp for non-magical patterns\n    // unescape anything in it, though, so that it'll be\n    // an exact match against a file etc.\n    if (!hasMagic) {\n        return globUnescape(pattern);\n    }\n    var flags = options.nocase ? \"i\" : \"\";\n    try {\n        var regExp = new RegExp(\"^\" + re + \"$\", flags);\n    } catch (er) /* istanbul ignore next - should be impossible */ {\n        // If it was an invalid regular expression, then it can't match\n        // anything.  This trick looks for a character after the end of\n        // the string, which is of course impossible, except in multi-line\n        // mode, but it's not a /m regex.\n        return new RegExp(\"$.\");\n    }\n    regExp._glob = pattern;\n    regExp._src = re;\n    return regExp;\n}\nminimatch.makeRe = function(pattern, options) {\n    return new Minimatch(pattern, options || {}).makeRe();\n};\nMinimatch.prototype.makeRe = makeRe;\nfunction makeRe() {\n    if (this.regexp || this.regexp === false) return this.regexp;\n    // at this point, this.set is a 2d array of partial\n    // pattern strings, or \"**\".\n    //\n    // It's better to use .match().  This function shouldn't\n    // be used, really, but it's pretty convenient sometimes,\n    // when you just want to work with a regex.\n    var set = this.set;\n    if (!set.length) {\n        this.regexp = false;\n        return this.regexp;\n    }\n    var options = this.options;\n    var twoStar = options.noglobstar ? star : options.dot ? twoStarDot : twoStarNoDot;\n    var flags = options.nocase ? \"i\" : \"\";\n    var re = set.map(function(pattern) {\n        return pattern.map(function(p) {\n            return p === GLOBSTAR ? twoStar : typeof p === \"string\" ? regExpEscape(p) : p._src;\n        }).join(\"\\\\/\");\n    }).join(\"|\");\n    // must match entire pattern\n    // ending in a * or ** will make it less strict.\n    re = \"^(?:\" + re + \")$\";\n    // can match anything, as long as it's not this.\n    if (this.negate) re = \"^(?!\" + re + \").*$\";\n    try {\n        this.regexp = new RegExp(re, flags);\n    } catch (ex) /* istanbul ignore next - should be impossible */ {\n        this.regexp = false;\n    }\n    return this.regexp;\n}\nminimatch.match = function(list, pattern, options) {\n    options = options || {};\n    var mm = new Minimatch(pattern, options);\n    list = list.filter(function(f) {\n        return mm.match(f);\n    });\n    if (mm.options.nonull && !list.length) {\n        list.push(pattern);\n    }\n    return list;\n};\nMinimatch.prototype.match = function match(f, partial) {\n    if (typeof partial === \"undefined\") partial = this.partial;\n    this.debug(\"match\", f, this.pattern);\n    // short-circuit in the case of busted things.\n    // comments, etc.\n    if (this.comment) return false;\n    if (this.empty) return f === \"\";\n    if (f === \"/\" && partial) return true;\n    var options = this.options;\n    // windows: need to use /, not \\\n    if (path.sep !== \"/\") {\n        f = f.split(path.sep).join(\"/\");\n    }\n    // treat the test path as a set of pathparts.\n    f = f.split(slashSplit);\n    this.debug(this.pattern, \"split\", f);\n    // just ONE of the pattern sets in this.set needs to match\n    // in order for it to be valid.  If negating, then just one\n    // match means that we have failed.\n    // Either way, return on the first hit.\n    var set = this.set;\n    this.debug(this.pattern, \"set\", set);\n    // Find the basename of the path by looking for the last non-empty segment\n    var filename;\n    var i;\n    for(i = f.length - 1; i >= 0; i--){\n        filename = f[i];\n        if (filename) break;\n    }\n    for(i = 0; i < set.length; i++){\n        var pattern = set[i];\n        var file = f;\n        if (options.matchBase && pattern.length === 1) {\n            file = [\n                filename\n            ];\n        }\n        var hit = this.matchOne(file, pattern, partial);\n        if (hit) {\n            if (options.flipNegate) return true;\n            return !this.negate;\n        }\n    }\n    // didn't get any hits.  this is success if it's a negative\n    // pattern, failure otherwise.\n    if (options.flipNegate) return false;\n    return this.negate;\n};\n// set partial to true to test if, for example,\n// \"/a/b\" matches the start of \"/*/b/*/d\"\n// Partial means, if you run out of file before you run\n// out of pattern, then that's fine, as long as all\n// the parts match.\nMinimatch.prototype.matchOne = function(file, pattern, partial) {\n    var options = this.options;\n    this.debug(\"matchOne\", {\n        \"this\": this,\n        file: file,\n        pattern: pattern\n    });\n    this.debug(\"matchOne\", file.length, pattern.length);\n    for(var fi = 0, pi = 0, fl = file.length, pl = pattern.length; fi < fl && pi < pl; fi++, pi++){\n        this.debug(\"matchOne loop\");\n        var p = pattern[pi];\n        var f = file[fi];\n        this.debug(pattern, p, f);\n        // should be impossible.\n        // some invalid regexp stuff in the set.\n        /* istanbul ignore if */ if (p === false) return false;\n        if (p === GLOBSTAR) {\n            this.debug(\"GLOBSTAR\", [\n                pattern,\n                p,\n                f\n            ]);\n            // \"**\"\n            // a/**/b/**/c would match the following:\n            // a/b/x/y/z/c\n            // a/x/y/z/b/c\n            // a/b/x/b/x/c\n            // a/b/c\n            // To do this, take the rest of the pattern after\n            // the **, and see if it would match the file remainder.\n            // If so, return success.\n            // If not, the ** \"swallows\" a segment, and try again.\n            // This is recursively awful.\n            //\n            // a/**/b/**/c matching a/b/x/y/z/c\n            // - a matches a\n            // - doublestar\n            //   - matchOne(b/x/y/z/c, b/**/c)\n            //     - b matches b\n            //     - doublestar\n            //       - matchOne(x/y/z/c, c) -> no\n            //       - matchOne(y/z/c, c) -> no\n            //       - matchOne(z/c, c) -> no\n            //       - matchOne(c, c) yes, hit\n            var fr = fi;\n            var pr = pi + 1;\n            if (pr === pl) {\n                this.debug(\"** at the end\");\n                // a ** at the end will just swallow the rest.\n                // We have found a match.\n                // however, it will not swallow /.x, unless\n                // options.dot is set.\n                // . and .. are *never* matched by **, for explosively\n                // exponential reasons.\n                for(; fi < fl; fi++){\n                    if (file[fi] === \".\" || file[fi] === \"..\" || !options.dot && file[fi].charAt(0) === \".\") return false;\n                }\n                return true;\n            }\n            // ok, let's see if we can swallow whatever we can.\n            while(fr < fl){\n                var swallowee = file[fr];\n                this.debug(\"\\nglobstar while\", file, fr, pattern, pr, swallowee);\n                // XXX remove this slice.  Just pass the start index.\n                if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {\n                    this.debug(\"globstar found match!\", fr, fl, swallowee);\n                    // found a match.\n                    return true;\n                } else {\n                    // can't swallow \".\" or \"..\" ever.\n                    // can only swallow \".foo\" when explicitly asked.\n                    if (swallowee === \".\" || swallowee === \"..\" || !options.dot && swallowee.charAt(0) === \".\") {\n                        this.debug(\"dot detected!\", file, fr, pattern, pr);\n                        break;\n                    }\n                    // ** swallows a segment, and continue.\n                    this.debug(\"globstar swallow a segment, and continue\");\n                    fr++;\n                }\n            }\n            // no match was found.\n            // However, in partial mode, we can't say this is necessarily over.\n            // If there's more *pattern* left, then\n            /* istanbul ignore if */ if (partial) {\n                // ran out of file\n                this.debug(\"\\n>>> no match, partial?\", file, fr, pattern, pr);\n                if (fr === fl) return true;\n            }\n            return false;\n        }\n        // something other than **\n        // non-magic patterns just have to match exactly\n        // patterns with magic have been turned into regexps.\n        var hit;\n        if (typeof p === \"string\") {\n            hit = f === p;\n            this.debug(\"string match\", p, f, hit);\n        } else {\n            hit = f.match(p);\n            this.debug(\"pattern match\", p, f, hit);\n        }\n        if (!hit) return false;\n    }\n    // Note: ending in / means that we'll get a final \"\"\n    // at the end of the pattern.  This can only match a\n    // corresponding \"\" at the end of the file.\n    // If the file ends in /, then it can only match a\n    // a pattern that ends in /, unless the pattern just\n    // doesn't have any more for it. But, a/b/ should *not*\n    // match \"a/b/*\", even though \"\" matches against the\n    // [^/]*? pattern, except in partial mode, where it might\n    // simply not be reached yet.\n    // However, a/b/ should still satisfy a/*\n    // now either we fell off the end of the pattern, or we're done.\n    if (fi === fl && pi === pl) {\n        // ran out of pattern and filename at the same time.\n        // an exact hit!\n        return true;\n    } else if (fi === fl) {\n        // ran out of file, but still had pattern left.\n        // this is ok if we're doing the match as part of\n        // a glob fs traversal.\n        return partial;\n    } else /* istanbul ignore else */ if (pi === pl) {\n        // ran out of pattern, still have file left.\n        // this is only acceptable if we're on the very last\n        // empty segment of a file with a trailing slash.\n        // a/* should match a/b/\n        return fi === fl - 1 && file[fi] === \"\";\n    }\n    // should be unreachable.\n    /* istanbul ignore next */ throw new Error(\"wtf?\");\n};\n// replace stuff like \\* with *\nfunction globUnescape(s) {\n    return s.replace(/\\\\(.)/g, \"$1\");\n}\nfunction regExpEscape(s) {\n    return s.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, \"\\\\$&\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbWluaW1hdGNoL21pbmltYXRjaC5qcyIsIm1hcHBpbmdzIjoiQUFBQUEsT0FBT0MsT0FBTyxHQUFHQztBQUNqQkEsVUFBVUMsU0FBUyxHQUFHQTtBQUV0QixJQUFJQyxPQUFPO0lBQWUsSUFBSTtRQUFFLE9BQU9DLG1CQUFPQSxDQUFDO0lBQVEsRUFBRSxPQUFPQyxHQUFHLENBQUM7QUFBQyxPQUFRO0lBQzNFQyxLQUFLO0FBQ1A7QUFDQUwsVUFBVUssR0FBRyxHQUFHSCxLQUFLRyxHQUFHO0FBRXhCLElBQUlDLFdBQVdOLFVBQVVNLFFBQVEsR0FBR0wsVUFBVUssUUFBUSxHQUFHLENBQUM7QUFDMUQsSUFBSUMsU0FBU0osbUJBQU9BLENBQUM7QUFFckIsSUFBSUssVUFBVTtJQUNaLEtBQUs7UUFBRUMsTUFBTTtRQUFhQyxPQUFPO0lBQVc7SUFDNUMsS0FBSztRQUFFRCxNQUFNO1FBQU9DLE9BQU87SUFBSztJQUNoQyxLQUFLO1FBQUVELE1BQU07UUFBT0MsT0FBTztJQUFLO0lBQ2hDLEtBQUs7UUFBRUQsTUFBTTtRQUFPQyxPQUFPO0lBQUs7SUFDaEMsS0FBSztRQUFFRCxNQUFNO1FBQU9DLE9BQU87SUFBSTtBQUNqQztBQUVBLGdDQUFnQztBQUNoQyxpREFBaUQ7QUFDakQsSUFBSUMsUUFBUTtBQUVaLGdDQUFnQztBQUNoQyxJQUFJQyxPQUFPRCxRQUFRO0FBRW5CLDREQUE0RDtBQUM1RCwrREFBK0Q7QUFDL0QsNkNBQTZDO0FBQzdDLElBQUlFLGFBQWE7QUFFakIsa0NBQWtDO0FBQ2xDLDZDQUE2QztBQUM3QyxJQUFJQyxlQUFlO0FBRW5CLGdEQUFnRDtBQUNoRCxJQUFJQyxhQUFhQyxRQUFRO0FBRXpCLHNDQUFzQztBQUN0QyxTQUFTQSxRQUFTQyxDQUFDO0lBQ2pCLE9BQU9BLEVBQUVDLEtBQUssQ0FBQyxJQUFJQyxNQUFNLENBQUMsU0FBVUMsR0FBRyxFQUFFQyxDQUFDO1FBQ3hDRCxHQUFHLENBQUNDLEVBQUUsR0FB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QW9EO0lBQ3BELHlEQUF5RDtJQUN6RCw2QkFBNkI7SUFDN0IseUNBQXlDO0lBRXpDLGdFQUFnRTtJQUNoRSxJQUFJRyxPQUFPRSxNQUFNRCxPQUFPM0MsSUFBSTtRQUMxQixvREFBb0Q7UUFDcEQsZ0JBQWdCO1FBQ2hCLE9BQU87SUFDVCxPQUFPLElBQUkwQyxPQUFPRSxJQUFJO1FBQ3BCLCtDQUErQztRQUMvQyxpREFBaUQ7UUFDakQsdUJBQXVCO1FBQ3ZCLE9BQU8xRjtJQUNULE9BQU8sd0JBQXdCLEdBQUcsSUFBSXlGLE9BQU8zQyxJQUFJO1FBQy9DLDRDQUE0QztRQUM1QyxvREFBb0Q7UUFDcEQsaURBQWlEO1FBQ2pELHdCQUF3QjtRQUN4QixPQUFPLE9BQVE0QyxLQUFLLEtBQU9QLElBQUksQ0FBQ0ssR0FBRyxLQUFLO0lBQzFDO0lBRUEseUJBQXlCO0lBQ3pCLHdCQUF3QixHQUN4QixNQUFNLElBQUlNLE1BQU07QUFDbEI7QUFFQSwrQkFBK0I7QUFDL0IsU0FBU3ZCLGFBQWM3RyxDQUFDO0lBQ3RCLE9BQU9BLEVBQUU4RixPQUFPLENBQUMsVUFBVTtBQUM3QjtBQUVBLFNBQVNxQixhQUFjbkgsQ0FBQztJQUN0QixPQUFPQSxFQUFFOEYsT0FBTyxDQUFDLDRCQUE0QjtBQUMvQyIsInNvdXJjZXMiOlsid2VicGFjazovL3RpbWVzaGVldC1wcm9jZXNzb3IvLi9ub2RlX21vZHVsZXMvbWluaW1hdGNoL21pbmltYXRjaC5qcz80ODUwIl0sInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gbWluaW1hdGNoXG5taW5pbWF0Y2guTWluaW1hdGNoID0gTWluaW1hdGNoXG5cbnZhciBwYXRoID0gKGZ1bmN0aW9uICgpIHsgdHJ5IHsgcmV0dXJuIHJlcXVpcmUoJ3BhdGgnKSB9IGNhdGNoIChlKSB7fX0oKSkgfHwge1xuICBzZXA6ICcvJ1xufVxubWluaW1hdGNoLnNlcCA9IHBhdGguc2VwXG5cbnZhciBHTE9CU1RBUiA9IG1pbmltYXRjaC5HTE9CU1RBUiA9IE1pbmltYXRjaC5HTE9CU1RBUiA9IHt9XG52YXIgZXhwYW5kID0gcmVxdWlyZSgnYnJhY2UtZXhwYW5zaW9uJylcblxudmFyIHBsVHlwZXMgPSB7XG4gICchJzogeyBvcGVuOiAnKD86KD8hKD86JywgY2xvc2U6ICcpKVteL10qPyknfSxcbiAgJz8nOiB7IG9wZW46ICcoPzonLCBjbG9zZTogJyk/JyB9LFxuICAnKyc6IHsgb3BlbjogJyg/OicsIGNsb3NlOiAnKSsnIH0sXG4gICcqJzogeyBvcGVuOiAnKD86JywgY2xvc2U6ICcpKicgfSxcbiAgJ0AnOiB7IG9wZW46ICcoPzonLCBjbG9zZTogJyknIH1cbn1cblxuLy8gYW55IHNpbmdsZSB0aGluZyBvdGhlciB0aGFuIC9cbi8vIGRvbid0IG5lZWQgdG8gZXNjYXBlIC8gd2hlbiB1c2luZyBuZXcgUmVnRXhwKClcbnZhciBxbWFyayA9ICdbXi9dJ1xuXG4vLyAqID0+IGFueSBudW1iZXIgb2YgY2hhcmFjdGVyc1xudmFyIHN0YXIgPSBxbWFyayArICcqPydcblxuLy8gKiogd2hlbiBkb3RzIGFyZSBhbGxvd2VkLiAgQW55dGhpbmcgZ29lcywgZXhjZXB0IC4uIGFuZCAuXG4vLyBub3QgKF4gb3IgLyBmb2xsb3dlZCBieSBvbmUgb3IgdHdvIGRvdHMgZm9sbG93ZWQgYnkgJCBvciAvKSxcbi8vIGZvbGxvd2VkIGJ5IGFueXRoaW5nLCBhbnkgbnVtYmVyIG9mIHRpbWVzLlxudmFyIHR3b1N0YXJEb3QgPSAnKD86KD8hKD86XFxcXFxcL3xeKSg/OlxcXFwuezEsMn0pKCR8XFxcXFxcLykpLikqPydcblxuLy8gbm90IGEgXiBvciAvIGZvbGxvd2VkIGJ5IGEgZG90LFxuLy8gZm9sbG93ZWQgYnkgYW55dGhpbmcsIGFueSBudW1iZXIgb2YgdGltZXMuXG52YXIgdHdvU3Rhck5vRG90ID0gJyg/Oig/ISg/OlxcXFxcXC98XilcXFxcLikuKSo/J1xuXG4vLyBjaGFyYWN0ZXJzIHRoYXQgbmVlZCB0byBiZSBlc2NhcGVkIGluIFJlZ0V4cC5cbnZhciByZVNwZWNpYWxzID0gY2hhclNldCgnKCkuKnt9Kz9bXV4kXFxcXCEnKVxuXG4vLyBcImFiY1wiIC0+IHsgYTp0cnVlLCBiOnRydWUsIGM6dHJ1ZSB9XG5mdW5jdGlvbiBjaGFyU2V0IChzKSB7XG4gIHJldHVybiBzLnNwbGl0KCcnKS5yZWR1Y2UoZnVuY3Rpb24gKHNldCwgYykge1xuICAgIHNldFtjXSA9IHRydWVcbiAgICByZXR1cm4gc2V0XG4gIH0sIHt9KVxufVxuXG4vLyBub3JtYWxpemVzIHNsYXNoZXMuXG52YXIgc2xhc2hTcGxpdCA9IC9cXC8rL1xuXG5taW5pbWF0Y2guZmlsdGVyID0gZmlsdGVyXG5mdW5jdGlvbiBmaWx0ZXIgKHBhdHRlcm4sIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge31cbiAgcmV0dXJuIGZ1bmN0aW9uIChwLCBpLCBsaXN0KSB7XG4gICAgcmV0dXJuIG1pbmltYXRjaChwLCBwYXR0ZXJuLCBvcHRpb25zKVxuICB9XG59XG5cbmZ1bmN0aW9uIGV4dCAoYSwgYikge1xuICBiID0gYiB8fCB7fVxuICB2YXIgdCA9IHt9XG4gIE9iamVjdC5rZXlzKGEpLmZvckVhY2goZnVuY3Rpb24gKGspIHtcbiAgICB0W2tdID0gYVtrXVxuICB9KVxuICBPYmplY3Qua2V5cyhiKS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG4gICAgdFtrXSA9IGJba11cbiAgfSlcbiAgcmV0dXJuIHRcbn1cblxubWluaW1hdGNoLmRlZmF1bHRzID0gZnVuY3Rpb24gKGRlZikge1xuICBpZiAoIWRlZiB8fCB0eXBlb2YgZGVmICE9PSAnb2JqZWN0JyB8fCAhT2JqZWN0LmtleXMoZGVmKS5sZW5ndGgpIHtcbiAgICByZXR1cm4gbWluaW1hdGNoXG4gIH1cblxuICB2YXIgb3JpZyA9IG1pbmltYXRjaFxuXG4gIHZhciBtID0gZnVuY3Rpb24gbWluaW1hdGNoIChwLCBwYXR0ZXJuLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG9yaWcocCwgcGF0dGVybiwgZXh0KGRlZiwgb3B0aW9ucykpXG4gIH1cblxuICBtLk1pbmltYXRjaCA9IGZ1bmN0aW9uIE1pbmltYXRjaCAocGF0dGVybiwgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgb3JpZy5NaW5pbWF0Y2gocGF0dGVybiwgZXh0KGRlZiwgb3B0aW9ucykpXG4gIH1cbiAgbS5NaW5pbWF0Y2guZGVmYXVsdHMgPSBmdW5jdGlvbiBkZWZhdWx0cyAob3B0aW9ucykge1xuICAgIHJldHVybiBvcmlnLmRlZmF1bHRzKGV4dChkZWYsIG9wdGlvbnMpKS5NaW5pbWF0Y2hcbiAgfVxuXG4gIG0uZmlsdGVyID0gZnVuY3Rpb24gZmlsdGVyIChwYXR0ZXJuLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG9yaWcuZmlsdGVyKHBhdHRlcm4sIGV4dChkZWYsIG9wdGlvbnMpKVxuICB9XG5cbiAgbS5kZWZhdWx0cyA9IGZ1bmN0aW9uIGRlZmF1bHRzIChvcHRpb25zKSB7XG4gICAgcmV0dXJuIG9yaWcuZGVmYXVsdHMoZXh0KGRlZiwgb3B0aW9ucykpXG4gIH1cblxuICBtLm1ha2VSZSA9IGZ1bmN0aW9uIG1ha2VSZSAocGF0dGVybiwgb3B0aW9ucykge1xuICAgIHJldHVybiBvcmlnLm1ha2VSZShwYXR0ZXJuLCBleHQoZGVmLCBvcHRpb25zKSlcbiAgfVxuXG4gIG0uYnJhY2VFeHBhbmQgPSBmdW5jdGlvbiBicmFjZUV4cGFuZCAocGF0dGVybiwgb3B0aW9ucykge1xuICAgIHJldHVybiBvcmlnLmJyYWNlRXhwYW5kKHBhdHRlcm4sIGV4dChkZWYsIG9wdGlvbnMpKVxuICB9XG5cbiAgbS5tYXRjaCA9IGZ1bmN0aW9uIChsaXN0LCBwYXR0ZXJuLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG9yaWcubWF0Y2gobGlzdCwgcGF0dGVybiwgZXh0KGRlZiwgb3B0aW9ucykpXG4gIH1cblxuICByZXR1cm4gbVxufVxuXG5NaW5pbWF0Y2guZGVmYXVsdHMgPSBmdW5jdGlvbiAoZGVmKSB7XG4gIHJldHVybiBtaW5pbWF0Y2guZGVmYXVsdHMoZGVmKS5NaW5pbWF0Y2hcbn1cblxuZnVuY3Rpb24gbWluaW1hdGNoIChwLCBwYXR0ZXJuLCBvcHRpb25zKSB7XG4gIGFzc2VydFZhbGlkUGF0dGVybihwYXR0ZXJuKVxuXG4gIGlmICghb3B0aW9ucykgb3B0aW9ucyA9IHt9XG5cbiAgLy8gc2hvcnRjdXQ6IGNvbW1lbnRzIG1hdGNoIG5vdGhpbmcuXG4gIGlmICghb3B0aW9ucy5ub2NvbW1lbnQgJiYgcGF0dGVybi5jaGFyQXQoMCkgPT09ICcjJykge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgcmV0dXJuIG5ldyBNaW5pbWF0Y2gocGF0dGVybiwgb3B0aW9ucykubWF0Y2gocClcbn1cblxuZnVuY3Rpb24gTWluaW1hdGNoIChwYXR0ZXJuLCBvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBNaW5pbWF0Y2gpKSB7XG4gICAgcmV0dXJuIG5ldyBNaW5pbWF0Y2gocGF0dGVybiwgb3B0aW9ucylcbiAgfVxuXG4gIGFzc2VydFZhbGlkUGF0dGVybihwYXR0ZXJuKVxuXG4gIGlmICghb3B0aW9ucykgb3B0aW9ucyA9IHt9XG5cbiAgcGF0dGVybiA9IHBhdHRlcm4udHJpbSgpXG5cbiAgLy8gd2luZG93cyBzdXBwb3J0OiBuZWVkIHRvIHVzZSAvLCBub3QgXFxcbiAgaWYgKCFvcHRpb25zLmFsbG93V2luZG93c0VzY2FwZSAmJiBwYXRoLnNlcCAhPT0gJy8nKSB7XG4gICAgcGF0dGVybiA9IHBhdHRlcm4uc3BsaXQocGF0aC5zZXApLmpvaW4oJy8nKVxuICB9XG5cbiAgdGhpcy5vcHRpb25zID0gb3B0aW9uc1xuICB0aGlzLnNldCA9IFtdXG4gIHRoaXMucGF0dGVybiA9IHBhdHRlcm5cbiAgdGhpcy5yZWdleHAgPSBudWxsXG4gIHRoaXMubmVnYXRlID0gZmFsc2VcbiAgdGhpcy5jb21tZW50ID0gZmFsc2VcbiAgdGhpcy5lbXB0eSA9IGZhbHNlXG4gIHRoaXMucGFydGlhbCA9ICEhb3B0aW9ucy5wYXJ0aWFsXG5cbiAgLy8gbWFrZSB0aGUgc2V0IG9mIHJlZ2V4cHMgZXRjLlxuICB0aGlzLm1ha2UoKVxufVxuXG5NaW5pbWF0Y2gucHJvdG90eXBlLmRlYnVnID0gZnVuY3Rpb24gKCkge31cblxuTWluaW1hdGNoLnByb3RvdHlwZS5tYWtlID0gbWFrZVxuZnVuY3Rpb24gbWFrZSAoKSB7XG4gIHZhciBwYXR0ZXJuID0gdGhpcy5wYXR0ZXJuXG4gIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zXG5cbiAgLy8gZW1wdHkgcGF0dGVybnMgYW5kIGNvbW1lbnRzIG1hdGNoIG5vdGhpbmcuXG4gIGlmICghb3B0aW9ucy5ub2NvbW1lbnQgJiYgcGF0dGVybi5jaGFyQXQoMCkgPT09ICcjJykge1xuICAgIHRoaXMuY29tbWVudCA9IHRydWVcbiAgICByZXR1cm5cbiAgfVxuICBpZiAoIXBhdHRlcm4pIHtcbiAgICB0aGlzLmVtcHR5ID0gdHJ1ZVxuICAgIHJldHVyblxuICB9XG5cbiAgLy8gc3RlcCAxOiBmaWd1cmUgb3V0IG5lZ2F0aW9uLCBldGMuXG4gIHRoaXMucGFyc2VOZWdhdGUoKVxuXG4gIC8vIHN0ZXAgMjogZXhwYW5kIGJyYWNlc1xuICB2YXIgc2V0ID0gdGhpcy5nbG9iU2V0ID0gdGhpcy5icmFjZUV4cGFuZCgpXG5cbiAgaWYgKG9wdGlvbnMuZGVidWcpIHRoaXMuZGVidWcgPSBmdW5jdGlvbiBkZWJ1ZygpIHsgY29uc29sZS5lcnJvci5hcHBseShjb25zb2xlLCBhcmd1bWVudHMpIH1cblxuICB0aGlzLmRlYnVnKHRoaXMucGF0dGVybiwgc2V0KVxuXG4gIC8vIHN0ZXAgMzogbm93IHdlIGhhdmUgYSBzZXQsIHNvIHR1cm4gZWFjaCBvbmUgaW50byBhIHNlcmllcyBvZiBwYXRoLXBvcnRpb25cbiAgLy8gbWF0Y2hpbmcgcGF0dGVybnMuXG4gIC8vIFRoZXNlIHdpbGwgYmUgcmVnZXhwcywgZXhjZXB0IGluIHRoZSBjYXNlIG9mIFwiKipcIiwgd2hpY2ggaXNcbiAgLy8gc2V0IHRvIHRoZSBHTE9CU1RBUiBvYmplY3QgZm9yIGdsb2JzdGFyIGJlaGF2aW9yLFxuICAvLyBhbmQgd2lsbCBub3QgY29udGFpbiBhbnkgLyBjaGFyYWN0ZXJzXG4gIHNldCA9IHRoaXMuZ2xvYlBhcnRzID0gc2V0Lm1hcChmdW5jdGlvbiAocykge1xuICAgIHJldHVybiBzLnNwbGl0KHNsYXNoU3BsaXQpXG4gIH0pXG5cbiAgdGhpcy5kZWJ1Zyh0aGlzLnBhdHRlcm4sIHNldClcblxuICAvLyBnbG9iIC0tPiByZWdleHBzXG4gIHNldCA9IHNldC5tYXAoZnVuY3Rpb24gKHMsIHNpLCBzZXQpIHtcbiAgICByZXR1cm4gcy5tYXAodGhpcy5wYXJzZSwgdGhpcylcbiAgfSwgdGhpcylcblxuICB0aGlzLmRlYnVnKHRoaXMucGF0dGVybiwgc2V0KVxuXG4gIC8vIGZpbHRlciBvdXQgZXZlcnl0aGluZyB0aGF0IGRpZG4ndCBjb21waWxlIHByb3Blcmx5LlxuICBzZXQgPSBzZXQuZmlsdGVyKGZ1bmN0aW9uIChzKSB7XG4gICAgcmV0dXJuIHMuaW5kZXhPZihmYWxzZSkgPT09IC0xXG4gIH0pXG5cbiAgdGhpcy5kZWJ1Zyh0aGlzLnBhdHRlcm4sIHNldClcblxuICB0aGlzLnNldCA9IHNldFxufVxuXG5NaW5pbWF0Y2gucHJvdG90eXBlLnBhcnNlTmVnYXRlID0gcGFyc2VOZWdhdGVcbmZ1bmN0aW9uIHBhcnNlTmVnYXRlICgpIHtcbiAgdmFyIHBhdHRlcm4gPSB0aGlzLnBhdHRlcm5cbiAgdmFyIG5lZ2F0ZSA9IGZhbHNlXG4gIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zXG4gIHZhciBuZWdhdGVPZmZzZXQgPSAwXG5cbiAgaWYgKG9wdGlvbnMubm9uZWdhdGUpIHJldHVyblxuXG4gIGZvciAodmFyIGkgPSAwLCBsID0gcGF0dGVybi5sZW5ndGhcbiAgICA7IGkgPCBsICYmIHBhdHRlcm4uY2hhckF0KGkpID09PSAnISdcbiAgICA7IGkrKykge1xuICAgIG5lZ2F0ZSA9ICFuZWdhdGVcbiAgICBuZWdhdGVPZmZzZXQrK1xuICB9XG5cbiAgaWYgKG5lZ2F0ZU9mZnNldCkgdGhpcy5wYXR0ZXJuID0gcGF0dGVybi5zdWJzdHIobmVnYXRlT2Zmc2V0KVxuICB0aGlzLm5lZ2F0ZSA9IG5lZ2F0ZVxufVxuXG4vLyBCcmFjZSBleHBhbnNpb246XG4vLyBhe2IsY31kIC0+IGFiZCBhY2Rcbi8vIGF7Yix9YyAtPiBhYmMgYWNcbi8vIGF7MC4uM31kIC0+IGEwZCBhMWQgYTJkIGEzZFxuLy8gYXtiLGN7ZCxlfWZ9ZyAtPiBhYmcgYWNkZmcgYWNlZmdcbi8vIGF7YixjfWR7ZSxmfWcgLT4gYWJkZWcgYWNkZWcgYWJkZWcgYWJkZmdcbi8vXG4vLyBJbnZhbGlkIHNldHMgYXJlIG5vdCBleHBhbmRlZC5cbi8vIGF7Mi4ufWIgLT4gYXsyLi59YlxuLy8gYXtifWMgLT4gYXtifWNcbm1pbmltYXRjaC5icmFjZUV4cGFuZCA9IGZ1bmN0aW9uIChwYXR0ZXJuLCBvcHRpb25zKSB7XG4gIHJldHVybiBicmFjZUV4cGFuZChwYXR0ZXJuLCBvcHRpb25zKVxufVxuXG5NaW5pbWF0Y2gucHJvdG90eXBlLmJyYWNlRXhwYW5kID0gYnJhY2VFeHBhbmRcblxuZnVuY3Rpb24gYnJhY2VFeHBhbmQgKHBhdHRlcm4sIG9wdGlvbnMpIHtcbiAgaWYgKCFvcHRpb25zKSB7XG4gICAgaWYgKHRoaXMgaW5zdGFuY2VvZiBNaW5pbWF0Y2gpIHtcbiAgICAgIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnNcbiAgICB9IGVsc2Uge1xuICAgICAgb3B0aW9ucyA9IHt9XG4gICAgfVxuICB9XG5cbiAgcGF0dGVybiA9IHR5cGVvZiBwYXR0ZXJuID09PSAndW5kZWZpbmVkJ1xuICAgID8gdGhpcy5wYXR0ZXJuIDogcGF0dGVyblxuXG4gIGFzc2VydFZhbGlkUGF0dGVybihwYXR0ZXJuKVxuXG4gIC8vIFRoYW5rcyB0byBZZXRpbmcgTGkgPGh0dHBzOi8vZ2l0aHViLmNvbS95ZXRpbmdsaT4gZm9yXG4gIC8vIGltcHJvdmluZyB0aGlzIHJlZ2V4cCB0byBhdm9pZCBhIFJlRE9TIHZ1bG5lcmFiaWxpdHkuXG4gIGlmIChvcHRpb25zLm5vYnJhY2UgfHwgIS9cXHsoPzooPyFcXHspLikqXFx9Ly50ZXN0KHBhdHRlcm4pKSB7XG4gICAgLy8gc2hvcnRjdXQuIG5vIG5lZWQgdG8gZXhwYW5kLlxuICAgIHJldHVybiBbcGF0dGVybl1cbiAgfVxuXG4gIHJldHVybiBleHBhbmQocGF0dGVybilcbn1cblxudmFyIE1BWF9QQVRURVJOX0xFTkdUSCA9IDEwMjQgKiA2NFxudmFyIGFzc2VydFZhbGlkUGF0dGVybiA9IGZ1bmN0aW9uIChwYXR0ZXJuKSB7XG4gIGlmICh0eXBlb2YgcGF0dGVybiAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHBhdHRlcm4nKVxuICB9XG5cbiAgaWYgKHBhdHRlcm4ubGVuZ3RoID4gTUFYX1BBVFRFUk5fTEVOR1RIKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcigncGF0dGVybiBpcyB0b28gbG9uZycpXG4gIH1cbn1cblxuLy8gcGFyc2UgYSBjb21wb25lbnQgb2YgdGhlIGV4cGFuZGVkIHNldC5cbi8vIEF0IHRoaXMgcG9pbnQsIG5vIHBhdHRlcm4gbWF5IGNvbnRhaW4gXCIvXCIgaW4gaXRcbi8vIHNvIHdlJ3JlIGdvaW5nIHRvIHJldHVybiBhIDJkIGFycmF5LCB3aGVyZSBlYWNoIGVudHJ5IGlzIHRoZSBmdWxsXG4vLyBwYXR0ZXJuLCBzcGxpdCBvbiAnLycsIGFuZCB0aGVuIHR1cm5lZCBpbnRvIGEgcmVndWxhciBleHByZXNzaW9uLlxuLy8gQSByZWdleHAgaXMgbWFkZSBhdCB0aGUgZW5kIHdoaWNoIGpvaW5zIGVhY2ggYXJyYXkgd2l0aCBhblxuLy8gZXNjYXBlZCAvLCBhbmQgYW5vdGhlciBmdWxsIG9uZSB3aGljaCBqb2lucyBlYWNoIHJlZ2V4cCB3aXRoIHwuXG4vL1xuLy8gRm9sbG93aW5nIHRoZSBsZWFkIG9mIEJhc2ggNC4xLCBub3RlIHRoYXQgXCIqKlwiIG9ubHkgaGFzIHNwZWNpYWwgbWVhbmluZ1xuLy8gd2hlbiBpdCBpcyB0aGUgKm9ubHkqIHRoaW5nIGluIGEgcGF0aCBwb3J0aW9uLiAgT3RoZXJ3aXNlLCBhbnkgc2VyaWVzXG4vLyBvZiAqIGlzIGVxdWl2YWxlbnQgdG8gYSBzaW5nbGUgKi4gIEdsb2JzdGFyIGJlaGF2aW9yIGlzIGVuYWJsZWQgYnlcbi8vIGRlZmF1bHQsIGFuZCBjYW4gYmUgZGlzYWJsZWQgYnkgc2V0dGluZyBvcHRpb25zLm5vZ2xvYnN0YXIuXG5NaW5pbWF0Y2gucHJvdG90eXBlLnBhcnNlID0gcGFyc2VcbnZhciBTVUJQQVJTRSA9IHt9XG5mdW5jdGlvbiBwYXJzZSAocGF0dGVybiwgaXNTdWIpIHtcbiAgYXNzZXJ0VmFsaWRQYXR0ZXJuKHBhdHRlcm4pXG5cbiAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnNcblxuICAvLyBzaG9ydGN1dHNcbiAgaWYgKHBhdHRlcm4gPT09ICcqKicpIHtcbiAgICBpZiAoIW9wdGlvbnMubm9nbG9ic3RhcilcbiAgICAgIHJldHVybiBHTE9CU1RBUlxuICAgIGVsc2VcbiAgICAgIHBhdHRlcm4gPSAnKidcbiAgfVxuICBpZiAocGF0dGVybiA9PT0gJycpIHJldHVybiAnJ1xuXG4gIHZhciByZSA9ICcnXG4gIHZhciBoYXNNYWdpYyA9ICEhb3B0aW9ucy5ub2Nhc2VcbiAgdmFyIGVzY2FwaW5nID0gZmFsc2VcbiAgLy8gPyA9PiBvbmUgc2luZ2xlIGNoYXJhY3RlclxuICB2YXIgcGF0dGVybkxpc3RTdGFjayA9IFtdXG4gIHZhciBuZWdhdGl2ZUxpc3RzID0gW11cbiAgdmFyIHN0YXRlQ2hhclxuICB2YXIgaW5DbGFzcyA9IGZhbHNlXG4gIHZhciByZUNsYXNzU3RhcnQgPSAtMVxuICB2YXIgY2xhc3NTdGFydCA9IC0xXG4gIC8vIC4gYW5kIC4uIG5ldmVyIG1hdGNoIGFueXRoaW5nIHRoYXQgZG9lc24ndCBzdGFydCB3aXRoIC4sXG4gIC8vIGV2ZW4gd2hlbiBvcHRpb25zLmRvdCBpcyBzZXQuXG4gIHZhciBwYXR0ZXJuU3RhcnQgPSBwYXR0ZXJuLmNoYXJBdCgwKSA9PT0gJy4nID8gJycgLy8gYW55dGhpbmdcbiAgLy8gbm90IChzdGFydCBvciAvIGZvbGxvd2VkIGJ5IC4gb3IgLi4gZm9sbG93ZWQgYnkgLyBvciBlbmQpXG4gIDogb3B0aW9ucy5kb3QgPyAnKD8hKD86XnxcXFxcXFwvKVxcXFwuezEsMn0oPzokfFxcXFxcXC8pKSdcbiAgOiAnKD8hXFxcXC4pJ1xuICB2YXIgc2VsZiA9IHRoaXNcblxuICBmdW5jdGlvbiBjbGVhclN0YXRlQ2hhciAoKSB7XG4gICAgaWYgKHN0YXRlQ2hhcikge1xuICAgICAgLy8gd2UgaGFkIHNvbWUgc3RhdGUtdHJhY2tpbmcgY2hhcmFjdGVyXG4gICAgICAvLyB0aGF0IHdhc24ndCBjb25zdW1lZCBieSB0aGlzIHBhc3MuXG4gICAgICBzd2l0Y2ggKHN0YXRlQ2hhcikge1xuICAgICAgICBjYXNlICcqJzpcbiAgICAgICAgICByZSArPSBzdGFyXG4gICAgICAgICAgaGFzTWFnaWMgPSB0cnVlXG4gICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgJz8nOlxuICAgICAgICAgIHJlICs9IHFtYXJrXG4gICAgICAgICAgaGFzTWFnaWMgPSB0cnVlXG4gICAgICAgIGJyZWFrXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmUgKz0gJ1xcXFwnICsgc3RhdGVDaGFyXG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgICBzZWxmLmRlYnVnKCdjbGVhclN0YXRlQ2hhciAlaiAlaicsIHN0YXRlQ2hhciwgcmUpXG4gICAgICBzdGF0ZUNoYXIgPSBmYWxzZVxuICAgIH1cbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBwYXR0ZXJuLmxlbmd0aCwgY1xuICAgIDsgKGkgPCBsZW4pICYmIChjID0gcGF0dGVybi5jaGFyQXQoaSkpXG4gICAgOyBpKyspIHtcbiAgICB0aGlzLmRlYnVnKCclc1xcdCVzICVzICVqJywgcGF0dGVybiwgaSwgcmUsIGMpXG5cbiAgICAvLyBza2lwIG92ZXIgYW55IHRoYXQgYXJlIGVzY2FwZWQuXG4gICAgaWYgKGVzY2FwaW5nICYmIHJlU3BlY2lhbHNbY10pIHtcbiAgICAgIHJlICs9ICdcXFxcJyArIGNcbiAgICAgIGVzY2FwaW5nID0gZmFsc2VcbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuXG4gICAgc3dpdGNoIChjKSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgY2FzZSAnLyc6IHtcbiAgICAgICAgLy8gY29tcGxldGVseSBub3QgYWxsb3dlZCwgZXZlbiBlc2NhcGVkLlxuICAgICAgICAvLyBTaG91bGQgYWxyZWFkeSBiZSBwYXRoLXNwbGl0IGJ5IG5vdy5cbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG5cbiAgICAgIGNhc2UgJ1xcXFwnOlxuICAgICAgICBjbGVhclN0YXRlQ2hhcigpXG4gICAgICAgIGVzY2FwaW5nID0gdHJ1ZVxuICAgICAgY29udGludWVcblxuICAgICAgLy8gdGhlIHZhcmlvdXMgc3RhdGVDaGFyIHZhbHVlc1xuICAgICAgLy8gZm9yIHRoZSBcImV4dGdsb2JcIiBzdHVmZi5cbiAgICAgIGNhc2UgJz8nOlxuICAgICAgY2FzZSAnKic6XG4gICAgICBjYXNlICcrJzpcbiAgICAgIGNhc2UgJ0AnOlxuICAgICAgY2FzZSAnISc6XG4gICAgICAgIHRoaXMuZGVidWcoJyVzXFx0JXMgJXMgJWogPC0tIHN0YXRlQ2hhcicsIHBhdHRlcm4sIGksIHJlLCBjKVxuXG4gICAgICAgIC8vIGFsbCBvZiB0aG9zZSBhcmUgbGl0ZXJhbHMgaW5zaWRlIGEgY2xhc3MsIGV4Y2VwdCB0aGF0XG4gICAgICAgIC8vIHRoZSBnbG9iIFshYV0gbWVhbnMgW15hXSBpbiByZWdleHBcbiAgICAgICAgaWYgKGluQ2xhc3MpIHtcbiAgICAgICAgICB0aGlzLmRlYnVnKCcgIGluIGNsYXNzJylcbiAgICAgICAgICBpZiAoYyA9PT0gJyEnICYmIGkgPT09IGNsYXNzU3RhcnQgKyAxKSBjID0gJ14nXG4gICAgICAgICAgcmUgKz0gY1xuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiB3ZSBhbHJlYWR5IGhhdmUgYSBzdGF0ZUNoYXIsIHRoZW4gaXQgbWVhbnNcbiAgICAgICAgLy8gdGhhdCB0aGVyZSB3YXMgc29tZXRoaW5nIGxpa2UgKiogb3IgKz8gaW4gdGhlcmUuXG4gICAgICAgIC8vIEhhbmRsZSB0aGUgc3RhdGVDaGFyLCB0aGVuIHByb2NlZWQgd2l0aCB0aGlzIG9uZS5cbiAgICAgICAgc2VsZi5kZWJ1ZygnY2FsbCBjbGVhclN0YXRlQ2hhciAlaicsIHN0YXRlQ2hhcilcbiAgICAgICAgY2xlYXJTdGF0ZUNoYXIoKVxuICAgICAgICBzdGF0ZUNoYXIgPSBjXG4gICAgICAgIC8vIGlmIGV4dGdsb2IgaXMgZGlzYWJsZWQsIHRoZW4gKyhhc2RmfGZvbykgaXNuJ3QgYSB0aGluZy5cbiAgICAgICAgLy8ganVzdCBjbGVhciB0aGUgc3RhdGVjaGFyICpub3cqLCByYXRoZXIgdGhhbiBldmVuIGRpdmluZyBpbnRvXG4gICAgICAgIC8vIHRoZSBwYXR0ZXJuTGlzdCBzdHVmZi5cbiAgICAgICAgaWYgKG9wdGlvbnMubm9leHQpIGNsZWFyU3RhdGVDaGFyKClcbiAgICAgIGNvbnRpbnVlXG5cbiAgICAgIGNhc2UgJygnOlxuICAgICAgICBpZiAoaW5DbGFzcykge1xuICAgICAgICAgIHJlICs9ICcoJ1xuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXN0YXRlQ2hhcikge1xuICAgICAgICAgIHJlICs9ICdcXFxcKCdcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG5cbiAgICAgICAgcGF0dGVybkxpc3RTdGFjay5wdXNoKHtcbiAgICAgICAgICB0eXBlOiBzdGF0ZUNoYXIsXG4gICAgICAgICAgc3RhcnQ6IGkgLSAxLFxuICAgICAgICAgIHJlU3RhcnQ6IHJlLmxlbmd0aCxcbiAgICAgICAgICBvcGVuOiBwbFR5cGVzW3N0YXRlQ2hhcl0ub3BlbixcbiAgICAgICAgICBjbG9zZTogcGxUeXBlc1tzdGF0ZUNoYXJdLmNsb3NlXG4gICAgICAgIH0pXG4gICAgICAgIC8vIG5lZ2F0aW9uIGlzICg/Oig/IWpzKVteL10qKVxuICAgICAgICByZSArPSBzdGF0ZUNoYXIgPT09ICchJyA/ICcoPzooPyEoPzonIDogJyg/OidcbiAgICAgICAgdGhpcy5kZWJ1ZygncGxUeXBlICVqICVqJywgc3RhdGVDaGFyLCByZSlcbiAgICAgICAgc3RhdGVDaGFyID0gZmFsc2VcbiAgICAgIGNvbnRpbnVlXG5cbiAgICAgIGNhc2UgJyknOlxuICAgICAgICBpZiAoaW5DbGFzcyB8fCAhcGF0dGVybkxpc3RTdGFjay5sZW5ndGgpIHtcbiAgICAgICAgICByZSArPSAnXFxcXCknXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuXG4gICAgICAgIGNsZWFyU3RhdGVDaGFyKClcbiAgICAgICAgaGFzTWFnaWMgPSB0cnVlXG4gICAgICAgIHZhciBwbCA9IHBhdHRlcm5MaXN0U3RhY2sucG9wKClcbiAgICAgICAgLy8gbmVnYXRpb24gaXMgKD86KD8hanMpW14vXSopXG4gICAgICAgIC8vIFRoZSBvdGhlcnMgYXJlICg/OjxwYXR0ZXJuPik8dHlwZT5cbiAgICAgICAgcmUgKz0gcGwuY2xvc2VcbiAgICAgICAgaWYgKHBsLnR5cGUgPT09ICchJykge1xuICAgICAgICAgIG5lZ2F0aXZlTGlzdHMucHVzaChwbClcbiAgICAgICAgfVxuICAgICAgICBwbC5yZUVuZCA9IHJlLmxlbmd0aFxuICAgICAgY29udGludWVcblxuICAgICAgY2FzZSAnfCc6XG4gICAgICAgIGlmIChpbkNsYXNzIHx8ICFwYXR0ZXJuTGlzdFN0YWNrLmxlbmd0aCB8fCBlc2NhcGluZykge1xuICAgICAgICAgIHJlICs9ICdcXFxcfCdcbiAgICAgICAgICBlc2NhcGluZyA9IGZhbHNlXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuXG4gICAgICAgIGNsZWFyU3RhdGVDaGFyKClcbiAgICAgICAgcmUgKz0gJ3wnXG4gICAgICBjb250aW51ZVxuXG4gICAgICAvLyB0aGVzZSBhcmUgbW9zdGx5IHRoZSBzYW1lIGluIHJlZ2V4cCBhbmQgZ2xvYlxuICAgICAgY2FzZSAnWyc6XG4gICAgICAgIC8vIHN3YWxsb3cgYW55IHN0YXRlLXRyYWNraW5nIGNoYXIgYmVmb3JlIHRoZSBbXG4gICAgICAgIGNsZWFyU3RhdGVDaGFyKClcblxuICAgICAgICBpZiAoaW5DbGFzcykge1xuICAgICAgICAgIHJlICs9ICdcXFxcJyArIGNcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG5cbiAgICAgICAgaW5DbGFzcyA9IHRydWVcbiAgICAgICAgY2xhc3NTdGFydCA9IGlcbiAgICAgICAgcmVDbGFzc1N0YXJ0ID0gcmUubGVuZ3RoXG4gICAgICAgIHJlICs9IGNcbiAgICAgIGNvbnRpbnVlXG5cbiAgICAgIGNhc2UgJ10nOlxuICAgICAgICAvLyAgYSByaWdodCBicmFja2V0IHNoYWxsIGxvc2UgaXRzIHNwZWNpYWxcbiAgICAgICAgLy8gIG1lYW5pbmcgYW5kIHJlcHJlc2VudCBpdHNlbGYgaW5cbiAgICAgICAgLy8gIGEgYnJhY2tldCBleHByZXNzaW9uIGlmIGl0IG9jY3Vyc1xuICAgICAgICAvLyAgZmlyc3QgaW4gdGhlIGxpc3QuICAtLSBQT1NJWC4yIDIuOC4zLjJcbiAgICAgICAgaWYgKGkgPT09IGNsYXNzU3RhcnQgKyAxIHx8ICFpbkNsYXNzKSB7XG4gICAgICAgICAgcmUgKz0gJ1xcXFwnICsgY1xuICAgICAgICAgIGVzY2FwaW5nID0gZmFsc2VcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gaGFuZGxlIHRoZSBjYXNlIHdoZXJlIHdlIGxlZnQgYSBjbGFzcyBvcGVuLlxuICAgICAgICAvLyBcIlt6LWFdXCIgaXMgdmFsaWQsIGVxdWl2YWxlbnQgdG8gXCJcXFt6LWFcXF1cIlxuICAgICAgICAvLyBzcGxpdCB3aGVyZSB0aGUgbGFzdCBbIHdhcywgbWFrZSBzdXJlIHdlIGRvbid0IGhhdmVcbiAgICAgICAgLy8gYW4gaW52YWxpZCByZS4gaWYgc28sIHJlLXdhbGsgdGhlIGNvbnRlbnRzIG9mIHRoZVxuICAgICAgICAvLyB3b3VsZC1iZSBjbGFzcyB0byByZS10cmFuc2xhdGUgYW55IGNoYXJhY3RlcnMgdGhhdFxuICAgICAgICAvLyB3ZXJlIHBhc3NlZCB0aHJvdWdoIGFzLWlzXG4gICAgICAgIC8vIFRPRE86IEl0IHdvdWxkIHByb2JhYmx5IGJlIGZhc3RlciB0byBkZXRlcm1pbmUgdGhpc1xuICAgICAgICAvLyB3aXRob3V0IGEgdHJ5L2NhdGNoIGFuZCBhIG5ldyBSZWdFeHAsIGJ1dCBpdCdzIHRyaWNreVxuICAgICAgICAvLyB0byBkbyBzYWZlbHkuICBGb3Igbm93LCB0aGlzIGlzIHNhZmUgYW5kIHdvcmtzLlxuICAgICAgICB2YXIgY3MgPSBwYXR0ZXJuLnN1YnN0cmluZyhjbGFzc1N0YXJ0ICsgMSwgaSlcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBSZWdFeHAoJ1snICsgY3MgKyAnXScpXG4gICAgICAgIH0gY2F0Y2ggKGVyKSB7XG4gICAgICAgICAgLy8gbm90IGEgdmFsaWQgY2xhc3MhXG4gICAgICAgICAgdmFyIHNwID0gdGhpcy5wYXJzZShjcywgU1VCUEFSU0UpXG4gICAgICAgICAgcmUgPSByZS5zdWJzdHIoMCwgcmVDbGFzc1N0YXJ0KSArICdcXFxcWycgKyBzcFswXSArICdcXFxcXSdcbiAgICAgICAgICBoYXNNYWdpYyA9IGhhc01hZ2ljIHx8IHNwWzFdXG4gICAgICAgICAgaW5DbGFzcyA9IGZhbHNlXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGZpbmlzaCB1cCB0aGUgY2xhc3MuXG4gICAgICAgIGhhc01hZ2ljID0gdHJ1ZVxuICAgICAgICBpbkNsYXNzID0gZmFsc2VcbiAgICAgICAgcmUgKz0gY1xuICAgICAgY29udGludWVcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgLy8gc3dhbGxvdyBhbnkgc3RhdGUgY2hhciB0aGF0IHdhc24ndCBjb25zdW1lZFxuICAgICAgICBjbGVhclN0YXRlQ2hhcigpXG5cbiAgICAgICAgaWYgKGVzY2FwaW5nKSB7XG4gICAgICAgICAgLy8gbm8gbmVlZFxuICAgICAgICAgIGVzY2FwaW5nID0gZmFsc2VcbiAgICAgICAgfSBlbHNlIGlmIChyZVNwZWNpYWxzW2NdXG4gICAgICAgICAgJiYgIShjID09PSAnXicgJiYgaW5DbGFzcykpIHtcbiAgICAgICAgICByZSArPSAnXFxcXCdcbiAgICAgICAgfVxuXG4gICAgICAgIHJlICs9IGNcblxuICAgIH0gLy8gc3dpdGNoXG4gIH0gLy8gZm9yXG5cbiAgLy8gaGFuZGxlIHRoZSBjYXNlIHdoZXJlIHdlIGxlZnQgYSBjbGFzcyBvcGVuLlxuICAvLyBcIlthYmNcIiBpcyB2YWxpZCwgZXF1aXZhbGVudCB0byBcIlxcW2FiY1wiXG4gIGlmIChpbkNsYXNzKSB7XG4gICAgLy8gc3BsaXQgd2hlcmUgdGhlIGxhc3QgWyB3YXMsIGFuZCBlc2NhcGUgaXRcbiAgICAvLyB0aGlzIGlzIGEgaHVnZSBwaXRhLiAgV2Ugbm93IGhhdmUgdG8gcmUtd2Fsa1xuICAgIC8vIHRoZSBjb250ZW50cyBvZiB0aGUgd291bGQtYmUgY2xhc3MgdG8gcmUtdHJhbnNsYXRlXG4gICAgLy8gYW55IGNoYXJhY3RlcnMgdGhhdCB3ZXJlIHBhc3NlZCB0aHJvdWdoIGFzLWlzXG4gICAgY3MgPSBwYXR0ZXJuLnN1YnN0cihjbGFzc1N0YXJ0ICsgMSlcbiAgICBzcCA9IHRoaXMucGFyc2UoY3MsIFNVQlBBUlNFKVxuICAgIHJlID0gcmUuc3Vic3RyKDAsIHJlQ2xhc3NTdGFydCkgKyAnXFxcXFsnICsgc3BbMF1cbiAgICBoYXNNYWdpYyA9IGhhc01hZ2ljIHx8IHNwWzFdXG4gIH1cblxuICAvLyBoYW5kbGUgdGhlIGNhc2Ugd2hlcmUgd2UgaGFkIGEgKyggdGhpbmcgYXQgdGhlICplbmQqXG4gIC8vIG9mIHRoZSBwYXR0ZXJuLlxuICAvLyBlYWNoIHBhdHRlcm4gbGlzdCBzdGFjayBhZGRzIDMgY2hhcnMsIGFuZCB3ZSBuZWVkIHRvIGdvIHRocm91Z2hcbiAgLy8gYW5kIGVzY2FwZSBhbnkgfCBjaGFycyB0aGF0IHdlcmUgcGFzc2VkIHRocm91Z2ggYXMtaXMgZm9yIHRoZSByZWdleHAuXG4gIC8vIEdvIHRocm91Z2ggYW5kIGVzY2FwZSB0aGVtLCB0YWtpbmcgY2FyZSBub3QgdG8gZG91YmxlLWVzY2FwZSBhbnlcbiAgLy8gfCBjaGFycyB0aGF0IHdlcmUgYWxyZWFkeSBlc2NhcGVkLlxuICBmb3IgKHBsID0gcGF0dGVybkxpc3RTdGFjay5wb3AoKTsgcGw7IHBsID0gcGF0dGVybkxpc3RTdGFjay5wb3AoKSkge1xuICAgIHZhciB0YWlsID0gcmUuc2xpY2UocGwucmVTdGFydCArIHBsLm9wZW4ubGVuZ3RoKVxuICAgIHRoaXMuZGVidWcoJ3NldHRpbmcgdGFpbCcsIHJlLCBwbClcbiAgICAvLyBtYXliZSBzb21lIGV2ZW4gbnVtYmVyIG9mIFxcLCB0aGVuIG1heWJlIDEgXFwsIGZvbGxvd2VkIGJ5IGEgfFxuICAgIHRhaWwgPSB0YWlsLnJlcGxhY2UoLygoPzpcXFxcezJ9KXswLDY0fSkoXFxcXD8pXFx8L2csIGZ1bmN0aW9uIChfLCAkMSwgJDIpIHtcbiAgICAgIGlmICghJDIpIHtcbiAgICAgICAgLy8gdGhlIHwgaXNuJ3QgYWxyZWFkeSBlc2NhcGVkLCBzbyBlc2NhcGUgaXQuXG4gICAgICAgICQyID0gJ1xcXFwnXG4gICAgICB9XG5cbiAgICAgIC8vIG5lZWQgdG8gZXNjYXBlIGFsbCB0aG9zZSBzbGFzaGVzICphZ2FpbiosIHdpdGhvdXQgZXNjYXBpbmcgdGhlXG4gICAgICAvLyBvbmUgdGhhdCB3ZSBuZWVkIGZvciBlc2NhcGluZyB0aGUgfCBjaGFyYWN0ZXIuICBBcyBpdCB3b3JrcyBvdXQsXG4gICAgICAvLyBlc2NhcGluZyBhbiBldmVuIG51bWJlciBvZiBzbGFzaGVzIGNhbiBiZSBkb25lIGJ5IHNpbXBseSByZXBlYXRpbmdcbiAgICAgIC8vIGl0IGV4YWN0bHkgYWZ0ZXIgaXRzZWxmLiAgVGhhdCdzIHdoeSB0aGlzIHRyaWNrIHdvcmtzLlxuICAgICAgLy9cbiAgICAgIC8vIEkgYW0gc29ycnkgdGhhdCB5b3UgaGF2ZSB0byBzZWUgdGhpcy5cbiAgICAgIHJldHVybiAkMSArICQxICsgJDIgKyAnfCdcbiAgICB9KVxuXG4gICAgdGhpcy5kZWJ1ZygndGFpbD0lalxcbiAgICVzJywgdGFpbCwgdGFpbCwgcGwsIHJlKVxuICAgIHZhciB0ID0gcGwudHlwZSA9PT0gJyonID8gc3RhclxuICAgICAgOiBwbC50eXBlID09PSAnPycgPyBxbWFya1xuICAgICAgOiAnXFxcXCcgKyBwbC50eXBlXG5cbiAgICBoYXNNYWdpYyA9IHRydWVcbiAgICByZSA9IHJlLnNsaWNlKDAsIHBsLnJlU3RhcnQpICsgdCArICdcXFxcKCcgKyB0YWlsXG4gIH1cblxuICAvLyBoYW5kbGUgdHJhaWxpbmcgdGhpbmdzIHRoYXQgb25seSBtYXR0ZXIgYXQgdGhlIHZlcnkgZW5kLlxuICBjbGVhclN0YXRlQ2hhcigpXG4gIGlmIChlc2NhcGluZykge1xuICAgIC8vIHRyYWlsaW5nIFxcXFxcbiAgICByZSArPSAnXFxcXFxcXFwnXG4gIH1cblxuICAvLyBvbmx5IG5lZWQgdG8gYXBwbHkgdGhlIG5vZG90IHN0YXJ0IGlmIHRoZSByZSBzdGFydHMgd2l0aFxuICAvLyBzb21ldGhpbmcgdGhhdCBjb3VsZCBjb25jZWl2YWJseSBjYXB0dXJlIGEgZG90XG4gIHZhciBhZGRQYXR0ZXJuU3RhcnQgPSBmYWxzZVxuICBzd2l0Y2ggKHJlLmNoYXJBdCgwKSkge1xuICAgIGNhc2UgJ1snOiBjYXNlICcuJzogY2FzZSAnKCc6IGFkZFBhdHRlcm5TdGFydCA9IHRydWVcbiAgfVxuXG4gIC8vIEhhY2sgdG8gd29yayBhcm91bmQgbGFjayBvZiBuZWdhdGl2ZSBsb29rYmVoaW5kIGluIEpTXG4gIC8vIEEgcGF0dGVybiBsaWtlOiAqLiEoeCkuISh5fHopIG5lZWRzIHRvIGVuc3VyZSB0aGF0IGEgbmFtZVxuICAvLyBsaWtlICdhLnh5ei55eicgZG9lc24ndCBtYXRjaC4gIFNvLCB0aGUgZmlyc3QgbmVnYXRpdmVcbiAgLy8gbG9va2FoZWFkLCBoYXMgdG8gbG9vayBBTEwgdGhlIHdheSBhaGVhZCwgdG8gdGhlIGVuZCBvZlxuICAvLyB0aGUgcGF0dGVybi5cbiAgZm9yICh2YXIgbiA9IG5lZ2F0aXZlTGlzdHMubGVuZ3RoIC0gMTsgbiA+IC0xOyBuLS0pIHtcbiAgICB2YXIgbmwgPSBuZWdhdGl2ZUxpc3RzW25dXG5cbiAgICB2YXIgbmxCZWZvcmUgPSByZS5zbGljZSgwLCBubC5yZVN0YXJ0KVxuICAgIHZhciBubEZpcnN0ID0gcmUuc2xpY2UobmwucmVTdGFydCwgbmwucmVFbmQgLSA4KVxuICAgIHZhciBubExhc3QgPSByZS5zbGljZShubC5yZUVuZCAtIDgsIG5sLnJlRW5kKVxuICAgIHZhciBubEFmdGVyID0gcmUuc2xpY2UobmwucmVFbmQpXG5cbiAgICBubExhc3QgKz0gbmxBZnRlclxuXG4gICAgLy8gSGFuZGxlIG5lc3RlZCBzdHVmZiBsaWtlICooKi5qc3whKCouanNvbikpLCB3aGVyZSBvcGVuIHBhcmVuc1xuICAgIC8vIG1lYW4gdGhhdCB3ZSBzaG91bGQgKm5vdCogaW5jbHVkZSB0aGUgKSBpbiB0aGUgYml0IHRoYXQgaXMgY29uc2lkZXJlZFxuICAgIC8vIFwiYWZ0ZXJcIiB0aGUgbmVnYXRlZCBzZWN0aW9uLlxuICAgIHZhciBvcGVuUGFyZW5zQmVmb3JlID0gbmxCZWZvcmUuc3BsaXQoJygnKS5sZW5ndGggLSAxXG4gICAgdmFyIGNsZWFuQWZ0ZXIgPSBubEFmdGVyXG4gICAgZm9yIChpID0gMDsgaSA8IG9wZW5QYXJlbnNCZWZvcmU7IGkrKykge1xuICAgICAgY2xlYW5BZnRlciA9IGNsZWFuQWZ0ZXIucmVwbGFjZSgvXFwpWysqP10/LywgJycpXG4gICAgfVxuICAgIG5sQWZ0ZXIgPSBjbGVhbkFmdGVyXG5cbiAgICB2YXIgZG9sbGFyID0gJydcbiAgICBpZiAobmxBZnRlciA9PT0gJycgJiYgaXNTdWIgIT09IFNVQlBBUlNFKSB7XG4gICAgICBkb2xsYXIgPSAnJCdcbiAgICB9XG4gICAgdmFyIG5ld1JlID0gbmxCZWZvcmUgKyBubEZpcnN0ICsgbmxBZnRlciArIGRvbGxhciArIG5sTGFzdFxuICAgIHJlID0gbmV3UmVcbiAgfVxuXG4gIC8vIGlmIHRoZSByZSBpcyBub3QgXCJcIiBhdCB0aGlzIHBvaW50LCB0aGVuIHdlIG5lZWQgdG8gbWFrZSBzdXJlXG4gIC8vIGl0IGRvZXNuJ3QgbWF0Y2ggYWdhaW5zdCBhbiBlbXB0eSBwYXRoIHBhcnQuXG4gIC8vIE90aGVyd2lzZSBhLyogd2lsbCBtYXRjaCBhLywgd2hpY2ggaXQgc2hvdWxkIG5vdC5cbiAgaWYgKHJlICE9PSAnJyAmJiBoYXNNYWdpYykge1xuICAgIHJlID0gJyg/PS4pJyArIHJlXG4gIH1cblxuICBpZiAoYWRkUGF0dGVyblN0YXJ0KSB7XG4gICAgcmUgPSBwYXR0ZXJuU3RhcnQgKyByZVxuICB9XG5cbiAgLy8gcGFyc2luZyBqdXN0IGEgcGllY2Ugb2YgYSBsYXJnZXIgcGF0dGVybi5cbiAgaWYgKGlzU3ViID09PSBTVUJQQVJTRSkge1xuICAgIHJldHVybiBbcmUsIGhhc01hZ2ljXVxuICB9XG5cbiAgLy8gc2tpcCB0aGUgcmVnZXhwIGZvciBub24tbWFnaWNhbCBwYXR0ZXJuc1xuICAvLyB1bmVzY2FwZSBhbnl0aGluZyBpbiBpdCwgdGhvdWdoLCBzbyB0aGF0IGl0J2xsIGJlXG4gIC8vIGFuIGV4YWN0IG1hdGNoIGFnYWluc3QgYSBmaWxlIGV0Yy5cbiAgaWYgKCFoYXNNYWdpYykge1xuICAgIHJldHVybiBnbG9iVW5lc2NhcGUocGF0dGVybilcbiAgfVxuXG4gIHZhciBmbGFncyA9IG9wdGlvbnMubm9jYXNlID8gJ2knIDogJydcbiAgdHJ5IHtcbiAgICB2YXIgcmVnRXhwID0gbmV3IFJlZ0V4cCgnXicgKyByZSArICckJywgZmxhZ3MpXG4gIH0gY2F0Y2ggKGVyKSAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAtIHNob3VsZCBiZSBpbXBvc3NpYmxlICovIHtcbiAgICAvLyBJZiBpdCB3YXMgYW4gaW52YWxpZCByZWd1bGFyIGV4cHJlc3Npb24sIHRoZW4gaXQgY2FuJ3QgbWF0Y2hcbiAgICAvLyBhbnl0aGluZy4gIFRoaXMgdHJpY2sgbG9va3MgZm9yIGEgY2hhcmFjdGVyIGFmdGVyIHRoZSBlbmQgb2ZcbiAgICAvLyB0aGUgc3RyaW5nLCB3aGljaCBpcyBvZiBjb3Vyc2UgaW1wb3NzaWJsZSwgZXhjZXB0IGluIG11bHRpLWxpbmVcbiAgICAvLyBtb2RlLCBidXQgaXQncyBub3QgYSAvbSByZWdleC5cbiAgICByZXR1cm4gbmV3IFJlZ0V4cCgnJC4nKVxuICB9XG5cbiAgcmVnRXhwLl9nbG9iID0gcGF0dGVyblxuICByZWdFeHAuX3NyYyA9IHJlXG5cbiAgcmV0dXJuIHJlZ0V4cFxufVxuXG5taW5pbWF0Y2gubWFrZVJlID0gZnVuY3Rpb24gKHBhdHRlcm4sIG9wdGlvbnMpIHtcbiAgcmV0dXJuIG5ldyBNaW5pbWF0Y2gocGF0dGVybiwgb3B0aW9ucyB8fCB7fSkubWFrZVJlKClcbn1cblxuTWluaW1hdGNoLnByb3RvdHlwZS5tYWtlUmUgPSBtYWtlUmVcbmZ1bmN0aW9uIG1ha2VSZSAoKSB7XG4gIGlmICh0aGlzLnJlZ2V4cCB8fCB0aGlzLnJlZ2V4cCA9PT0gZmFsc2UpIHJldHVybiB0aGlzLnJlZ2V4cFxuXG4gIC8vIGF0IHRoaXMgcG9pbnQsIHRoaXMuc2V0IGlzIGEgMmQgYXJyYXkgb2YgcGFydGlhbFxuICAvLyBwYXR0ZXJuIHN0cmluZ3MsIG9yIFwiKipcIi5cbiAgLy9cbiAgLy8gSXQncyBiZXR0ZXIgdG8gdXNlIC5tYXRjaCgpLiAgVGhpcyBmdW5jdGlvbiBzaG91bGRuJ3RcbiAgLy8gYmUgdXNlZCwgcmVhbGx5LCBidXQgaXQncyBwcmV0dHkgY29udmVuaWVudCBzb21ldGltZXMsXG4gIC8vIHdoZW4geW91IGp1c3Qgd2FudCB0byB3b3JrIHdpdGggYSByZWdleC5cbiAgdmFyIHNldCA9IHRoaXMuc2V0XG5cbiAgaWYgKCFzZXQubGVuZ3RoKSB7XG4gICAgdGhpcy5yZWdleHAgPSBmYWxzZVxuICAgIHJldHVybiB0aGlzLnJlZ2V4cFxuICB9XG4gIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zXG5cbiAgdmFyIHR3b1N0YXIgPSBvcHRpb25zLm5vZ2xvYnN0YXIgPyBzdGFyXG4gICAgOiBvcHRpb25zLmRvdCA/IHR3b1N0YXJEb3RcbiAgICA6IHR3b1N0YXJOb0RvdFxuICB2YXIgZmxhZ3MgPSBvcHRpb25zLm5vY2FzZSA/ICdpJyA6ICcnXG5cbiAgdmFyIHJlID0gc2V0Lm1hcChmdW5jdGlvbiAocGF0dGVybikge1xuICAgIHJldHVybiBwYXR0ZXJuLm1hcChmdW5jdGlvbiAocCkge1xuICAgICAgcmV0dXJuIChwID09PSBHTE9CU1RBUikgPyB0d29TdGFyXG4gICAgICA6ICh0eXBlb2YgcCA9PT0gJ3N0cmluZycpID8gcmVnRXhwRXNjYXBlKHApXG4gICAgICA6IHAuX3NyY1xuICAgIH0pLmpvaW4oJ1xcXFxcXC8nKVxuICB9KS5qb2luKCd8JylcblxuICAvLyBtdXN0IG1hdGNoIGVudGlyZSBwYXR0ZXJuXG4gIC8vIGVuZGluZyBpbiBhICogb3IgKiogd2lsbCBtYWtlIGl0IGxlc3Mgc3RyaWN0LlxuICByZSA9ICdeKD86JyArIHJlICsgJykkJ1xuXG4gIC8vIGNhbiBtYXRjaCBhbnl0aGluZywgYXMgbG9uZyBhcyBpdCdzIG5vdCB0aGlzLlxuICBpZiAodGhpcy5uZWdhdGUpIHJlID0gJ14oPyEnICsgcmUgKyAnKS4qJCdcblxuICB0cnkge1xuICAgIHRoaXMucmVnZXhwID0gbmV3IFJlZ0V4cChyZSwgZmxhZ3MpXG4gIH0gY2F0Y2ggKGV4KSAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAtIHNob3VsZCBiZSBpbXBvc3NpYmxlICovIHtcbiAgICB0aGlzLnJlZ2V4cCA9IGZhbHNlXG4gIH1cbiAgcmV0dXJuIHRoaXMucmVnZXhwXG59XG5cbm1pbmltYXRjaC5tYXRjaCA9IGZ1bmN0aW9uIChsaXN0LCBwYXR0ZXJuLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9XG4gIHZhciBtbSA9IG5ldyBNaW5pbWF0Y2gocGF0dGVybiwgb3B0aW9ucylcbiAgbGlzdCA9IGxpc3QuZmlsdGVyKGZ1bmN0aW9uIChmKSB7XG4gICAgcmV0dXJuIG1tLm1hdGNoKGYpXG4gIH0pXG4gIGlmIChtbS5vcHRpb25zLm5vbnVsbCAmJiAhbGlzdC5sZW5ndGgpIHtcbiAgICBsaXN0LnB1c2gocGF0dGVybilcbiAgfVxuICByZXR1cm4gbGlzdFxufVxuXG5NaW5pbWF0Y2gucHJvdG90eXBlLm1hdGNoID0gZnVuY3Rpb24gbWF0Y2ggKGYsIHBhcnRpYWwpIHtcbiAgaWYgKHR5cGVvZiBwYXJ0aWFsID09PSAndW5kZWZpbmVkJykgcGFydGlhbCA9IHRoaXMucGFydGlhbFxuICB0aGlzLmRlYnVnKCdtYXRjaCcsIGYsIHRoaXMucGF0dGVybilcbiAgLy8gc2hvcnQtY2lyY3VpdCBpbiB0aGUgY2FzZSBvZiBidXN0ZWQgdGhpbmdzLlxuICAvLyBjb21tZW50cywgZXRjLlxuICBpZiAodGhpcy5jb21tZW50KSByZXR1cm4gZmFsc2VcbiAgaWYgKHRoaXMuZW1wdHkpIHJldHVybiBmID09PSAnJ1xuXG4gIGlmIChmID09PSAnLycgJiYgcGFydGlhbCkgcmV0dXJuIHRydWVcblxuICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9uc1xuXG4gIC8vIHdpbmRvd3M6IG5lZWQgdG8gdXNlIC8sIG5vdCBcXFxuICBpZiAocGF0aC5zZXAgIT09ICcvJykge1xuICAgIGYgPSBmLnNwbGl0KHBhdGguc2VwKS5qb2luKCcvJylcbiAgfVxuXG4gIC8vIHRyZWF0IHRoZSB0ZXN0IHBhdGggYXMgYSBzZXQgb2YgcGF0aHBhcnRzLlxuICBmID0gZi5zcGxpdChzbGFzaFNwbGl0KVxuICB0aGlzLmRlYnVnKHRoaXMucGF0dGVybiwgJ3NwbGl0JywgZilcblxuICAvLyBqdXN0IE9ORSBvZiB0aGUgcGF0dGVybiBzZXRzIGluIHRoaXMuc2V0IG5lZWRzIHRvIG1hdGNoXG4gIC8vIGluIG9yZGVyIGZvciBpdCB0byBiZSB2YWxpZC4gIElmIG5lZ2F0aW5nLCB0aGVuIGp1c3Qgb25lXG4gIC8vIG1hdGNoIG1lYW5zIHRoYXQgd2UgaGF2ZSBmYWlsZWQuXG4gIC8vIEVpdGhlciB3YXksIHJldHVybiBvbiB0aGUgZmlyc3QgaGl0LlxuXG4gIHZhciBzZXQgPSB0aGlzLnNldFxuICB0aGlzLmRlYnVnKHRoaXMucGF0dGVybiwgJ3NldCcsIHNldClcblxuICAvLyBGaW5kIHRoZSBiYXNlbmFtZSBvZiB0aGUgcGF0aCBieSBsb29raW5nIGZvciB0aGUgbGFzdCBub24tZW1wdHkgc2VnbWVudFxuICB2YXIgZmlsZW5hbWVcbiAgdmFyIGlcbiAgZm9yIChpID0gZi5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIGZpbGVuYW1lID0gZltpXVxuICAgIGlmIChmaWxlbmFtZSkgYnJlYWtcbiAgfVxuXG4gIGZvciAoaSA9IDA7IGkgPCBzZXQubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcGF0dGVybiA9IHNldFtpXVxuICAgIHZhciBmaWxlID0gZlxuICAgIGlmIChvcHRpb25zLm1hdGNoQmFzZSAmJiBwYXR0ZXJuLmxlbmd0aCA9PT0gMSkge1xuICAgICAgZmlsZSA9IFtmaWxlbmFtZV1cbiAgICB9XG4gICAgdmFyIGhpdCA9IHRoaXMubWF0Y2hPbmUoZmlsZSwgcGF0dGVybiwgcGFydGlhbClcbiAgICBpZiAoaGl0KSB7XG4gICAgICBpZiAob3B0aW9ucy5mbGlwTmVnYXRlKSByZXR1cm4gdHJ1ZVxuICAgICAgcmV0dXJuICF0aGlzLm5lZ2F0ZVxuICAgIH1cbiAgfVxuXG4gIC8vIGRpZG4ndCBnZXQgYW55IGhpdHMuICB0aGlzIGlzIHN1Y2Nlc3MgaWYgaXQncyBhIG5lZ2F0aXZlXG4gIC8vIHBhdHRlcm4sIGZhaWx1cmUgb3RoZXJ3aXNlLlxuICBpZiAob3B0aW9ucy5mbGlwTmVnYXRlKSByZXR1cm4gZmFsc2VcbiAgcmV0dXJuIHRoaXMubmVnYXRlXG59XG5cbi8vIHNldCBwYXJ0aWFsIHRvIHRydWUgdG8gdGVzdCBpZiwgZm9yIGV4YW1wbGUsXG4vLyBcIi9hL2JcIiBtYXRjaGVzIHRoZSBzdGFydCBvZiBcIi8qL2IvKi9kXCJcbi8vIFBhcnRpYWwgbWVhbnMsIGlmIHlvdSBydW4gb3V0IG9mIGZpbGUgYmVmb3JlIHlvdSBydW5cbi8vIG91dCBvZiBwYXR0ZXJuLCB0aGVuIHRoYXQncyBmaW5lLCBhcyBsb25nIGFzIGFsbFxuLy8gdGhlIHBhcnRzIG1hdGNoLlxuTWluaW1hdGNoLnByb3RvdHlwZS5tYXRjaE9uZSA9IGZ1bmN0aW9uIChmaWxlLCBwYXR0ZXJuLCBwYXJ0aWFsKSB7XG4gIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zXG5cbiAgdGhpcy5kZWJ1ZygnbWF0Y2hPbmUnLFxuICAgIHsgJ3RoaXMnOiB0aGlzLCBmaWxlOiBmaWxlLCBwYXR0ZXJuOiBwYXR0ZXJuIH0pXG5cbiAgdGhpcy5kZWJ1ZygnbWF0Y2hPbmUnLCBmaWxlLmxlbmd0aCwgcGF0dGVybi5sZW5ndGgpXG5cbiAgZm9yICh2YXIgZmkgPSAwLFxuICAgICAgcGkgPSAwLFxuICAgICAgZmwgPSBmaWxlLmxlbmd0aCxcbiAgICAgIHBsID0gcGF0dGVybi5sZW5ndGhcbiAgICAgIDsgKGZpIDwgZmwpICYmIChwaSA8IHBsKVxuICAgICAgOyBmaSsrLCBwaSsrKSB7XG4gICAgdGhpcy5kZWJ1ZygnbWF0Y2hPbmUgbG9vcCcpXG4gICAgdmFyIHAgPSBwYXR0ZXJuW3BpXVxuICAgIHZhciBmID0gZmlsZVtmaV1cblxuICAgIHRoaXMuZGVidWcocGF0dGVybiwgcCwgZilcblxuICAgIC8vIHNob3VsZCBiZSBpbXBvc3NpYmxlLlxuICAgIC8vIHNvbWUgaW52YWxpZCByZWdleHAgc3R1ZmYgaW4gdGhlIHNldC5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAocCA9PT0gZmFsc2UpIHJldHVybiBmYWxzZVxuXG4gICAgaWYgKHAgPT09IEdMT0JTVEFSKSB7XG4gICAgICB0aGlzLmRlYnVnKCdHTE9CU1RBUicsIFtwYXR0ZXJuLCBwLCBmXSlcblxuICAgICAgLy8gXCIqKlwiXG4gICAgICAvLyBhLyoqL2IvKiovYyB3b3VsZCBtYXRjaCB0aGUgZm9sbG93aW5nOlxuICAgICAgLy8gYS9iL3gveS96L2NcbiAgICAgIC8vIGEveC95L3ovYi9jXG4gICAgICAvLyBhL2IveC9iL3gvY1xuICAgICAgLy8gYS9iL2NcbiAgICAgIC8vIFRvIGRvIHRoaXMsIHRha2UgdGhlIHJlc3Qgb2YgdGhlIHBhdHRlcm4gYWZ0ZXJcbiAgICAgIC8vIHRoZSAqKiwgYW5kIHNlZSBpZiBpdCB3b3VsZCBtYXRjaCB0aGUgZmlsZSByZW1haW5kZXIuXG4gICAgICAvLyBJZiBzbywgcmV0dXJuIHN1Y2Nlc3MuXG4gICAgICAvLyBJZiBub3QsIHRoZSAqKiBcInN3YWxsb3dzXCIgYSBzZWdtZW50LCBhbmQgdHJ5IGFnYWluLlxuICAgICAgLy8gVGhpcyBpcyByZWN1cnNpdmVseSBhd2Z1bC5cbiAgICAgIC8vXG4gICAgICAvLyBhLyoqL2IvKiovYyBtYXRjaGluZyBhL2IveC95L3ovY1xuICAgICAgLy8gLSBhIG1hdGNoZXMgYVxuICAgICAgLy8gLSBkb3VibGVzdGFyXG4gICAgICAvLyAgIC0gbWF0Y2hPbmUoYi94L3kvei9jLCBiLyoqL2MpXG4gICAgICAvLyAgICAgLSBiIG1hdGNoZXMgYlxuICAgICAgLy8gICAgIC0gZG91Ymxlc3RhclxuICAgICAgLy8gICAgICAgLSBtYXRjaE9uZSh4L3kvei9jLCBjKSAtPiBub1xuICAgICAgLy8gICAgICAgLSBtYXRjaE9uZSh5L3ovYywgYykgLT4gbm9cbiAgICAgIC8vICAgICAgIC0gbWF0Y2hPbmUoei9jLCBjKSAtPiBub1xuICAgICAgLy8gICAgICAgLSBtYXRjaE9uZShjLCBjKSB5ZXMsIGhpdFxuICAgICAgdmFyIGZyID0gZmlcbiAgICAgIHZhciBwciA9IHBpICsgMVxuICAgICAgaWYgKHByID09PSBwbCkge1xuICAgICAgICB0aGlzLmRlYnVnKCcqKiBhdCB0aGUgZW5kJylcbiAgICAgICAgLy8gYSAqKiBhdCB0aGUgZW5kIHdpbGwganVzdCBzd2FsbG93IHRoZSByZXN0LlxuICAgICAgICAvLyBXZSBoYXZlIGZvdW5kIGEgbWF0Y2guXG4gICAgICAgIC8vIGhvd2V2ZXIsIGl0IHdpbGwgbm90IHN3YWxsb3cgLy54LCB1bmxlc3NcbiAgICAgICAgLy8gb3B0aW9ucy5kb3QgaXMgc2V0LlxuICAgICAgICAvLyAuIGFuZCAuLiBhcmUgKm5ldmVyKiBtYXRjaGVkIGJ5ICoqLCBmb3IgZXhwbG9zaXZlbHlcbiAgICAgICAgLy8gZXhwb25lbnRpYWwgcmVhc29ucy5cbiAgICAgICAgZm9yICg7IGZpIDwgZmw7IGZpKyspIHtcbiAgICAgICAgICBpZiAoZmlsZVtmaV0gPT09ICcuJyB8fCBmaWxlW2ZpXSA9PT0gJy4uJyB8fFxuICAgICAgICAgICAgKCFvcHRpb25zLmRvdCAmJiBmaWxlW2ZpXS5jaGFyQXQoMCkgPT09ICcuJykpIHJldHVybiBmYWxzZVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG5cbiAgICAgIC8vIG9rLCBsZXQncyBzZWUgaWYgd2UgY2FuIHN3YWxsb3cgd2hhdGV2ZXIgd2UgY2FuLlxuICAgICAgd2hpbGUgKGZyIDwgZmwpIHtcbiAgICAgICAgdmFyIHN3YWxsb3dlZSA9IGZpbGVbZnJdXG5cbiAgICAgICAgdGhpcy5kZWJ1ZygnXFxuZ2xvYnN0YXIgd2hpbGUnLCBmaWxlLCBmciwgcGF0dGVybiwgcHIsIHN3YWxsb3dlZSlcblxuICAgICAgICAvLyBYWFggcmVtb3ZlIHRoaXMgc2xpY2UuICBKdXN0IHBhc3MgdGhlIHN0YXJ0IGluZGV4LlxuICAgICAgICBpZiAodGhpcy5tYXRjaE9uZShmaWxlLnNsaWNlKGZyKSwgcGF0dGVybi5zbGljZShwciksIHBhcnRpYWwpKSB7XG4gICAgICAgICAgdGhpcy5kZWJ1ZygnZ2xvYnN0YXIgZm91bmQgbWF0Y2ghJywgZnIsIGZsLCBzd2FsbG93ZWUpXG4gICAgICAgICAgLy8gZm91bmQgYSBtYXRjaC5cbiAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGNhbid0IHN3YWxsb3cgXCIuXCIgb3IgXCIuLlwiIGV2ZXIuXG4gICAgICAgICAgLy8gY2FuIG9ubHkgc3dhbGxvdyBcIi5mb29cIiB3aGVuIGV4cGxpY2l0bHkgYXNrZWQuXG4gICAgICAgICAgaWYgKHN3YWxsb3dlZSA9PT0gJy4nIHx8IHN3YWxsb3dlZSA9PT0gJy4uJyB8fFxuICAgICAgICAgICAgKCFvcHRpb25zLmRvdCAmJiBzd2FsbG93ZWUuY2hhckF0KDApID09PSAnLicpKSB7XG4gICAgICAgICAgICB0aGlzLmRlYnVnKCdkb3QgZGV0ZWN0ZWQhJywgZmlsZSwgZnIsIHBhdHRlcm4sIHByKVxuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyAqKiBzd2FsbG93cyBhIHNlZ21lbnQsIGFuZCBjb250aW51ZS5cbiAgICAgICAgICB0aGlzLmRlYnVnKCdnbG9ic3RhciBzd2FsbG93IGEgc2VnbWVudCwgYW5kIGNvbnRpbnVlJylcbiAgICAgICAgICBmcisrXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gbm8gbWF0Y2ggd2FzIGZvdW5kLlxuICAgICAgLy8gSG93ZXZlciwgaW4gcGFydGlhbCBtb2RlLCB3ZSBjYW4ndCBzYXkgdGhpcyBpcyBuZWNlc3NhcmlseSBvdmVyLlxuICAgICAgLy8gSWYgdGhlcmUncyBtb3JlICpwYXR0ZXJuKiBsZWZ0LCB0aGVuXG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmIChwYXJ0aWFsKSB7XG4gICAgICAgIC8vIHJhbiBvdXQgb2YgZmlsZVxuICAgICAgICB0aGlzLmRlYnVnKCdcXG4+Pj4gbm8gbWF0Y2gsIHBhcnRpYWw/JywgZmlsZSwgZnIsIHBhdHRlcm4sIHByKVxuICAgICAgICBpZiAoZnIgPT09IGZsKSByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgLy8gc29tZXRoaW5nIG90aGVyIHRoYW4gKipcbiAgICAvLyBub24tbWFnaWMgcGF0dGVybnMganVzdCBoYXZlIHRvIG1hdGNoIGV4YWN0bHlcbiAgICAvLyBwYXR0ZXJucyB3aXRoIG1hZ2ljIGhhdmUgYmVlbiB0dXJuZWQgaW50byByZWdleHBzLlxuICAgIHZhciBoaXRcbiAgICBpZiAodHlwZW9mIHAgPT09ICdzdHJpbmcnKSB7XG4gICAgICBoaXQgPSBmID09PSBwXG4gICAgICB0aGlzLmRlYnVnKCdzdHJpbmcgbWF0Y2gnLCBwLCBmLCBoaXQpXG4gICAgfSBlbHNlIHtcbiAgICAgIGhpdCA9IGYubWF0Y2gocClcbiAgICAgIHRoaXMuZGVidWcoJ3BhdHRlcm4gbWF0Y2gnLCBwLCBmLCBoaXQpXG4gICAgfVxuXG4gICAgaWYgKCFoaXQpIHJldHVybiBmYWxzZVxuICB9XG5cbiAgLy8gTm90ZTogZW5kaW5nIGluIC8gbWVhbnMgdGhhdCB3ZSdsbCBnZXQgYSBmaW5hbCBcIlwiXG4gIC8vIGF0IHRoZSBlbmQgb2YgdGhlIHBhdHRlcm4uICBUaGlzIGNhbiBvbmx5IG1hdGNoIGFcbiAgLy8gY29ycmVzcG9uZGluZyBcIlwiIGF0IHRoZSBlbmQgb2YgdGhlIGZpbGUuXG4gIC8vIElmIHRoZSBmaWxlIGVuZHMgaW4gLywgdGhlbiBpdCBjYW4gb25seSBtYXRjaCBhXG4gIC8vIGEgcGF0dGVybiB0aGF0IGVuZHMgaW4gLywgdW5sZXNzIHRoZSBwYXR0ZXJuIGp1c3RcbiAgLy8gZG9lc24ndCBoYXZlIGFueSBtb3JlIGZvciBpdC4gQnV0LCBhL2IvIHNob3VsZCAqbm90KlxuICAvLyBtYXRjaCBcImEvYi8qXCIsIGV2ZW4gdGhvdWdoIFwiXCIgbWF0Y2hlcyBhZ2FpbnN0IHRoZVxuICAvLyBbXi9dKj8gcGF0dGVybiwgZXhjZXB0IGluIHBhcnRpYWwgbW9kZSwgd2hlcmUgaXQgbWlnaHRcbiAgLy8gc2ltcGx5IG5vdCBiZSByZWFjaGVkIHlldC5cbiAgLy8gSG93ZXZlciwgYS9iLyBzaG91bGQgc3RpbGwgc2F0aXNmeSBhLypcblxuICAvLyBub3cgZWl0aGVyIHdlIGZlbGwgb2ZmIHRoZSBlbmQgb2YgdGhlIHBhdHRlcm4sIG9yIHdlJ3JlIGRvbmUuXG4gIGlmIChmaSA9PT0gZmwgJiYgcGkgPT09IHBsKSB7XG4gICAgLy8gcmFuIG91dCBvZiBwYXR0ZXJuIGFuZCBmaWxlbmFtZSBhdCB0aGUgc2FtZSB0aW1lLlxuICAgIC8vIGFuIGV4YWN0IGhpdCFcbiAgICByZXR1cm4gdHJ1ZVxuICB9IGVsc2UgaWYgKGZpID09PSBmbCkge1xuICAgIC8vIHJhbiBvdXQgb2YgZmlsZSwgYnV0IHN0aWxsIGhhZCBwYXR0ZXJuIGxlZnQuXG4gICAgLy8gdGhpcyBpcyBvayBpZiB3ZSdyZSBkb2luZyB0aGUgbWF0Y2ggYXMgcGFydCBvZlxuICAgIC8vIGEgZ2xvYiBmcyB0cmF2ZXJzYWwuXG4gICAgcmV0dXJuIHBhcnRpYWxcbiAgfSBlbHNlIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovIGlmIChwaSA9PT0gcGwpIHtcbiAgICAvLyByYW4gb3V0IG9mIHBhdHRlcm4sIHN0aWxsIGhhdmUgZmlsZSBsZWZ0LlxuICAgIC8vIHRoaXMgaXMgb25seSBhY2NlcHRhYmxlIGlmIHdlJ3JlIG9uIHRoZSB2ZXJ5IGxhc3RcbiAgICAvLyBlbXB0eSBzZWdtZW50IG9mIGEgZmlsZSB3aXRoIGEgdHJhaWxpbmcgc2xhc2guXG4gICAgLy8gYS8qIHNob3VsZCBtYXRjaCBhL2IvXG4gICAgcmV0dXJuIChmaSA9PT0gZmwgLSAxKSAmJiAoZmlsZVtmaV0gPT09ICcnKVxuICB9XG5cbiAgLy8gc2hvdWxkIGJlIHVucmVhY2hhYmxlLlxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICB0aHJvdyBuZXcgRXJyb3IoJ3d0Zj8nKVxufVxuXG4vLyByZXBsYWNlIHN0dWZmIGxpa2UgXFwqIHdpdGggKlxuZnVuY3Rpb24gZ2xvYlVuZXNjYXBlIChzKSB7XG4gIHJldHVybiBzLnJlcGxhY2UoL1xcXFwoLikvZywgJyQxJylcbn1cblxuZnVuY3Rpb24gcmVnRXhwRXNjYXBlIChzKSB7XG4gIHJldHVybiBzLnJlcGxhY2UoL1stW1xcXXt9KCkqKz8uLFxcXFxeJHwjXFxzXS9nLCAnXFxcXCQmJylcbn1cbiJdLCJuYW1lcyI6WyJtb2R1bGUiLCJleHBvcnRzIiwibWluaW1hdGNoIiwiTWluaW1hdGNoIiwicGF0aCIsInJlcXVpcmUiLCJlIiwic2VwIiwiR0xPQlNUQVIiLCJleHBhbmQiLCJwbFR5cGVzIiwib3BlbiIsImNsb3NlIiwicW1hcmsiLCJzdGFyIiwidHdvU3RhckRvdCIsInR3b1N0YXJOb0RvdCIsInJlU3BlY2lhbHMiLCJjaGFyU2V0IiwicyIsInNwbGl0IiwicmVkdWNlIiwic2V0IiwiYyIsInNsYXNoU3BsaXQiLCJmaWx0ZXIiLCJwYXR0ZXJuIiwib3B0aW9ucyIsInAiLCJpIiwibGlzdCIsImV4dCIsImEiLCJiIiwidCIsIk9iamVjdCIsImtleXMiLCJmb3JFYWNoIiwiayIsImRlZmF1bHRzIiwiZGVmIiwibGVuZ3RoIiwib3JpZyIsIm0iLCJtYWtlUmUiLCJicmFjZUV4cGFuZCIsIm1hdGNoIiwiYXNzZXJ0VmFsaWRQYXR0ZXJuIiwibm9jb21tZW50IiwiY2hhckF0IiwidHJpbSIsImFsbG93V2luZG93c0VzY2FwZSIsImpvaW4iLCJyZWdleHAiLCJuZWdhdGUiLCJjb21tZW50IiwiZW1wdHkiLCJwYXJ0aWFsIiwibWFrZSIsInByb3RvdHlwZSIsImRlYnVnIiwicGFyc2VOZWdhdGUiLCJnbG9iU2V0IiwiY29uc29sZSIsImVycm9yIiwiYXBwbHkiLCJhcmd1bWVudHMiLCJnbG9iUGFydHMiLCJtYXAiLCJzaSIsInBhcnNlIiwiaW5kZXhPZiIsIm5lZ2F0ZU9mZnNldCIsIm5vbmVnYXRlIiwibCIsInN1YnN0ciIsIm5vYnJhY2UiLCJ0ZXN0IiwiTUFYX1BBVFRFUk5fTEVOR1RIIiwiVHlwZUVycm9yIiwiU1VCUEFSU0UiLCJpc1N1YiIsIm5vZ2xvYnN0YXIiLCJyZSIsImhhc01hZ2ljIiwibm9jYXNlIiwiZXNjYXBpbmciLCJwYXR0ZXJuTGlzdFN0YWNrIiwibmVnYXRpdmVMaXN0cyIsInN0YXRlQ2hhciIsImluQ2xhc3MiLCJyZUNsYXNzU3RhcnQiLCJjbGFzc1N0YXJ0IiwicGF0dGVyblN0YXJ0IiwiZG90Iiwic2VsZiIsImNsZWFyU3RhdGVDaGFyIiwibGVuIiwibm9leHQiLCJwdXNoIiwidHlwZSIsInN0YXJ0IiwicmVTdGFydCIsInBsIiwicG9wIiwicmVFbmQiLCJjcyIsInN1YnN0cmluZyIsIlJlZ0V4cCIsImVyIiwic3AiLCJ0YWlsIiwic2xpY2UiLCJyZXBsYWNlIiwiXyIsIiQxIiwiJDIiLCJhZGRQYXR0ZXJuU3RhcnQiLCJuIiwibmwiLCJubEJlZm9yZSIsIm5sRmlyc3QiLCJubExhc3QiLCJubEFmdGVyIiwib3BlblBhcmVuc0JlZm9yZSIsImNsZWFuQWZ0ZXIiLCJkb2xsYXIiLCJuZXdSZSIsImdsb2JVbmVzY2FwZSIsImZsYWdzIiwicmVnRXhwIiwiX2dsb2IiLCJfc3JjIiwidHdvU3RhciIsInJlZ0V4cEVzY2FwZSIsImV4IiwibW0iLCJmIiwibm9udWxsIiwiZmlsZW5hbWUiLCJmaWxlIiwibWF0Y2hCYXNlIiwiaGl0IiwibWF0Y2hPbmUiLCJmbGlwTmVnYXRlIiwiZmkiLCJwaSIsImZsIiwiZnIiLCJwciIsInN3YWxsb3dlZSIsIkVycm9yIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/minimatch/minimatch.js\n");

/***/ })

};
;