"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/bl";
exports.ids = ["vendor-chunks/bl"];
exports.modules = {

/***/ "(rsc)/./node_modules/bl/BufferList.js":
/*!***************************************!*\
  !*** ./node_modules/bl/BufferList.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst { Buffer } = __webpack_require__(/*! buffer */ \"buffer\");\nconst symbol = Symbol.for(\"BufferList\");\nfunction BufferList(buf) {\n    if (!(this instanceof BufferList)) {\n        return new BufferList(buf);\n    }\n    BufferList._init.call(this, buf);\n}\nBufferList._init = function _init(buf) {\n    Object.defineProperty(this, symbol, {\n        value: true\n    });\n    this._bufs = [];\n    this.length = 0;\n    if (buf) {\n        this.append(buf);\n    }\n};\nBufferList.prototype._new = function _new(buf) {\n    return new BufferList(buf);\n};\nBufferList.prototype._offset = function _offset(offset) {\n    if (offset === 0) {\n        return [\n            0,\n            0\n        ];\n    }\n    let tot = 0;\n    for(let i = 0; i < this._bufs.length; i++){\n        const _t = tot + this._bufs[i].length;\n        if (offset < _t || i === this._bufs.length - 1) {\n            return [\n                i,\n                offset - tot\n            ];\n        }\n        tot = _t;\n    }\n};\nBufferList.prototype._reverseOffset = function(blOffset) {\n    const bufferId = blOffset[0];\n    let offset = blOffset[1];\n    for(let i = 0; i < bufferId; i++){\n        offset += this._bufs[i].length;\n    }\n    return offset;\n};\nBufferList.prototype.get = function get(index) {\n    if (index > this.length || index < 0) {\n        return undefined;\n    }\n    const offset = this._offset(index);\n    return this._bufs[offset[0]][offset[1]];\n};\nBufferList.prototype.slice = function slice(start, end) {\n    if (typeof start === \"number\" && start < 0) {\n        start += this.length;\n    }\n    if (typeof end === \"number\" && end < 0) {\n        end += this.length;\n    }\n    return this.copy(null, 0, start, end);\n};\nBufferList.prototype.copy = function copy(dst, dstStart, srcStart, srcEnd) {\n    if (typeof srcStart !== \"number\" || srcStart < 0) {\n        srcStart = 0;\n    }\n    if (typeof srcEnd !== \"number\" || srcEnd > this.length) {\n        srcEnd = this.length;\n    }\n    if (srcStart >= this.length) {\n        return dst || Buffer.alloc(0);\n    }\n    if (srcEnd <= 0) {\n        return dst || Buffer.alloc(0);\n    }\n    const copy = !!dst;\n    const off = this._offset(srcStart);\n    const len = srcEnd - srcStart;\n    let bytes = len;\n    let bufoff = copy && dstStart || 0;\n    let start = off[1];\n    // copy/slice everything\n    if (srcStart === 0 && srcEnd === this.length) {\n        if (!copy) {\n            // slice, but full concat if multiple buffers\n            return this._bufs.length === 1 ? this._bufs[0] : Buffer.concat(this._bufs, this.length);\n        }\n        // copy, need to copy individual buffers\n        for(let i = 0; i < this._bufs.length; i++){\n            this._bufs[i].copy(dst, bufoff);\n            bufoff += this._bufs[i].length;\n        }\n        return dst;\n    }\n    // easy, cheap case where it's a subset of one of the buffers\n    if (bytes <= this._bufs[off[0]].length - start) {\n        return copy ? this._bufs[off[0]].copy(dst, dstStart, start, start + bytes) : this._bufs[off[0]].slice(start, start + bytes);\n    }\n    if (!copy) {\n        // a slice, we need something to copy in to\n        dst = Buffer.allocUnsafe(len);\n    }\n    for(let i = off[0]; i < this._bufs.length; i++){\n        const l = this._bufs[i].length - start;\n        if (bytes > l) {\n            this._bufs[i].copy(dst, bufoff, start);\n            bufoff += l;\n        } else {\n            this._bufs[i].copy(dst, bufoff, start, start + bytes);\n            bufoff += l;\n            break;\n        }\n        bytes -= l;\n        if (start) {\n            start = 0;\n        }\n    }\n    // safeguard so that we don't return uninitialized memory\n    if (dst.length > bufoff) return dst.slice(0, bufoff);\n    return dst;\n};\nBufferList.prototype.shallowSlice = function shallowSlice(start, end) {\n    start = start || 0;\n    end = typeof end !== \"number\" ? this.length : end;\n    if (start < 0) {\n        start += this.length;\n    }\n    if (end < 0) {\n        end += this.length;\n    }\n    if (start === end) {\n        return this._new();\n    }\n    const startOffset = this._offset(start);\n    const endOffset = this._offset(end);\n    const buffers = this._bufs.slice(startOffset[0], endOffset[0] + 1);\n    if (endOffset[1] === 0) {\n        buffers.pop();\n    } else {\n        buffers[buffers.length - 1] = buffers[buffers.length - 1].slice(0, endOffset[1]);\n    }\n    if (startOffset[1] !== 0) {\n        buffers[0] = buffers[0].slice(startOffset[1]);\n    }\n    return this._new(buffers);\n};\nBufferList.prototype.toString = function toString(encoding, start, end) {\n    return this.slice(start, end).toString(encoding);\n};\nBufferList.prototype.consume = function consume(bytes) {\n    // first, normalize the argument, in accordance with how Buffer does it\n    bytes = Math.trunc(bytes);\n    // do nothing if not a positive number\n    if (Number.isNaN(bytes) || bytes <= 0) return this;\n    while(this._bufs.length){\n        if (bytes >= this._bufs[0].length) {\n            bytes -= this._bufs[0].length;\n            this.length -= this._bufs[0].length;\n            this._bufs.shift();\n        } else {\n            this._bufs[0] = this._bufs[0].slice(bytes);\n            this.length -= bytes;\n            break;\n        }\n    }\n    return this;\n};\nBufferList.prototype.duplicate = function duplicate() {\n    const copy = this._new();\n    for(let i = 0; i < this._bufs.length; i++){\n        copy.append(this._bufs[i]);\n    }\n    return copy;\n};\nBufferList.prototype.append = function append(buf) {\n    if (buf == null) {\n        return this;\n    }\n    if (buf.buffer) {\n        // append a view of the underlying ArrayBuffer\n        this._appendBuffer(Buffer.from(buf.buffer, buf.byteOffset, buf.byteLength));\n    } else if (Array.isArray(buf)) {\n        for(let i = 0; i < buf.length; i++){\n            this.append(buf[i]);\n        }\n    } else if (this._isBufferList(buf)) {\n        // unwrap argument into individual BufferLists\n        for(let i = 0; i < buf._bufs.length; i++){\n            this.append(buf._bufs[i]);\n        }\n    } else {\n        // coerce number arguments to strings, since Buffer(number) does\n        // uninitialized memory allocation\n        if (typeof buf === \"number\") {\n            buf = buf.toString();\n        }\n        this._appendBuffer(Buffer.from(buf));\n    }\n    return this;\n};\nBufferList.prototype._appendBuffer = function appendBuffer(buf) {\n    this._bufs.push(buf);\n    this.length += buf.length;\n};\nBufferList.prototype.indexOf = function(search, offset, encoding) {\n    if (encoding === undefined && typeof offset === \"string\") {\n        encoding = offset;\n        offset = undefined;\n    }\n    if (typeof search === \"function\" || Array.isArray(search)) {\n        throw new TypeError('The \"value\" argument must be one of type string, Buffer, BufferList, or Uint8Array.');\n    } else if (typeof search === \"number\") {\n        search = Buffer.from([\n            search\n        ]);\n    } else if (typeof search === \"string\") {\n        search = Buffer.from(search, encoding);\n    } else if (this._isBufferList(search)) {\n        search = search.slice();\n    } else if (Array.isArray(search.buffer)) {\n        search = Buffer.from(search.buffer, search.byteOffset, search.byteLength);\n    } else if (!Buffer.isBuffer(search)) {\n        search = Buffer.from(search);\n    }\n    offset = Number(offset || 0);\n    if (isNaN(offset)) {\n        offset = 0;\n    }\n    if (offset < 0) {\n        offset = this.length + offset;\n    }\n    if (offset < 0) {\n        offset = 0;\n    }\n    if (search.length === 0) {\n        return offset > this.length ? this.length : offset;\n    }\n    const blOffset = this._offset(offset);\n    let blIndex = blOffset[0] // index of which internal buffer we're working on\n    ;\n    let buffOffset = blOffset[1] // offset of the internal buffer we're working on\n    ;\n    // scan over each buffer\n    for(; blIndex < this._bufs.length; blIndex++){\n        const buff = this._bufs[blIndex];\n        while(buffOffset < buff.length){\n            const availableWindow = buff.length - buffOffset;\n            if (availableWindow >= search.length) {\n                const nativeSearchResult = buff.indexOf(search, buffOffset);\n                if (nativeSearchResult !== -1) {\n                    return this._reverseOffset([\n                        blIndex,\n                        nativeSearchResult\n                    ]);\n                }\n                buffOffset = buff.length - search.length + 1 // end of native search window\n                ;\n            } else {\n                const revOffset = this._reverseOffset([\n                    blIndex,\n                    buffOffset\n                ]);\n                if (this._match(revOffset, search)) {\n                    return revOffset;\n                }\n                buffOffset++;\n            }\n        }\n        buffOffset = 0;\n    }\n    return -1;\n};\nBufferList.prototype._match = function(offset, search) {\n    if (this.length - offset < search.length) {\n        return false;\n    }\n    for(let searchOffset = 0; searchOffset < search.length; searchOffset++){\n        if (this.get(offset + searchOffset) !== search[searchOffset]) {\n            return false;\n        }\n    }\n    return true;\n};\n(function() {\n    const methods = {\n        readDoubleBE: 8,\n        readDoubleLE: 8,\n        readFloatBE: 4,\n        readFloatLE: 4,\n        readInt32BE: 4,\n        readInt32LE: 4,\n        readUInt32BE: 4,\n        readUInt32LE: 4,\n        readInt16BE: 2,\n        readInt16LE: 2,\n        readUInt16BE: 2,\n        readUInt16LE: 2,\n        readInt8: 1,\n        readUInt8: 1,\n        readIntBE: null,\n        readIntLE: null,\n        readUIntBE: null,\n        readUIntLE: null\n    };\n    for(const m in methods){\n        (function(m) {\n            if (methods[m] === null) {\n                BufferList.prototype[m] = function(offset, byteLength) {\n                    return this.slice(offset, offset + byteLength)[m](0, byteLength);\n                };\n            } else {\n                BufferList.prototype[m] = function(offset = 0) {\n                    return this.slice(offset, offset + methods[m])[m](0);\n                };\n            }\n        })(m);\n    }\n})();\n// Used internally by the class and also as an indicator of this object being\n// a `BufferList`. It's not possible to use `instanceof BufferList` in a browser\n// environment because there could be multiple different copies of the\n// BufferList class and some `BufferList`s might be `BufferList`s.\nBufferList.prototype._isBufferList = function _isBufferList(b) {\n    return b instanceof BufferList || BufferList.isBufferList(b);\n};\nBufferList.isBufferList = function isBufferList(b) {\n    return b != null && b[symbol];\n};\nmodule.exports = BufferList;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QU8sR0FBR2xHIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdGltZXNoZWV0LXByb2Nlc3Nvci8uL25vZGVfbW9kdWxlcy9ibC9CdWZmZXJMaXN0LmpzPzZkOGEiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHsgQnVmZmVyIH0gPSByZXF1aXJlKCdidWZmZXInKVxuY29uc3Qgc3ltYm9sID0gU3ltYm9sLmZvcignQnVmZmVyTGlzdCcpXG5cbmZ1bmN0aW9uIEJ1ZmZlckxpc3QgKGJ1Zikge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgQnVmZmVyTGlzdCkpIHtcbiAgICByZXR1cm4gbmV3IEJ1ZmZlckxpc3QoYnVmKVxuICB9XG5cbiAgQnVmZmVyTGlzdC5faW5pdC5jYWxsKHRoaXMsIGJ1Zilcbn1cblxuQnVmZmVyTGlzdC5faW5pdCA9IGZ1bmN0aW9uIF9pbml0IChidWYpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIHN5bWJvbCwgeyB2YWx1ZTogdHJ1ZSB9KVxuXG4gIHRoaXMuX2J1ZnMgPSBbXVxuICB0aGlzLmxlbmd0aCA9IDBcblxuICBpZiAoYnVmKSB7XG4gICAgdGhpcy5hcHBlbmQoYnVmKVxuICB9XG59XG5cbkJ1ZmZlckxpc3QucHJvdG90eXBlLl9uZXcgPSBmdW5jdGlvbiBfbmV3IChidWYpIHtcbiAgcmV0dXJuIG5ldyBCdWZmZXJMaXN0KGJ1Zilcbn1cblxuQnVmZmVyTGlzdC5wcm90b3R5cGUuX29mZnNldCA9IGZ1bmN0aW9uIF9vZmZzZXQgKG9mZnNldCkge1xuICBpZiAob2Zmc2V0ID09PSAwKSB7XG4gICAgcmV0dXJuIFswLCAwXVxuICB9XG5cbiAgbGV0IHRvdCA9IDBcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX2J1ZnMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBfdCA9IHRvdCArIHRoaXMuX2J1ZnNbaV0ubGVuZ3RoXG4gICAgaWYgKG9mZnNldCA8IF90IHx8IGkgPT09IHRoaXMuX2J1ZnMubGVuZ3RoIC0gMSkge1xuICAgICAgcmV0dXJuIFtpLCBvZmZzZXQgLSB0b3RdXG4gICAgfVxuICAgIHRvdCA9IF90XG4gIH1cbn1cblxuQnVmZmVyTGlzdC5wcm90b3R5cGUuX3JldmVyc2VPZmZzZXQgPSBmdW5jdGlvbiAoYmxPZmZzZXQpIHtcbiAgY29uc3QgYnVmZmVySWQgPSBibE9mZnNldFswXVxuICBsZXQgb2Zmc2V0ID0gYmxPZmZzZXRbMV1cblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGJ1ZmZlcklkOyBpKyspIHtcbiAgICBvZmZzZXQgKz0gdGhpcy5fYnVmc1tpXS5sZW5ndGhcbiAgfVxuXG4gIHJldHVybiBvZmZzZXRcbn1cblxuQnVmZmVyTGlzdC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gZ2V0IChpbmRleCkge1xuICBpZiAoaW5kZXggPiB0aGlzLmxlbmd0aCB8fCBpbmRleCA8IDApIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkXG4gIH1cblxuICBjb25zdCBvZmZzZXQgPSB0aGlzLl9vZmZzZXQoaW5kZXgpXG5cbiAgcmV0dXJuIHRoaXMuX2J1ZnNbb2Zmc2V0WzBdXVtvZmZzZXRbMV1dXG59XG5cbkJ1ZmZlckxpc3QucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24gc2xpY2UgKHN0YXJ0LCBlbmQpIHtcbiAgaWYgKHR5cGVvZiBzdGFydCA9PT0gJ251bWJlcicgJiYgc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgKz0gdGhpcy5sZW5ndGhcbiAgfVxuXG4gIGlmICh0eXBlb2YgZW5kID09PSAnbnVtYmVyJyAmJiBlbmQgPCAwKSB7XG4gICAgZW5kICs9IHRoaXMubGVuZ3RoXG4gIH1cblxuICByZXR1cm4gdGhpcy5jb3B5KG51bGwsIDAsIHN0YXJ0LCBlbmQpXG59XG5cbkJ1ZmZlckxpc3QucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiBjb3B5IChkc3QsIGRzdFN0YXJ0LCBzcmNTdGFydCwgc3JjRW5kKSB7XG4gIGlmICh0eXBlb2Ygc3JjU3RhcnQgIT09ICdudW1iZXInIHx8IHNyY1N0YXJ0IDwgMCkge1xuICAgIHNyY1N0YXJ0ID0gMFxuICB9XG5cbiAgaWYgKHR5cGVvZiBzcmNFbmQgIT09ICdudW1iZXInIHx8IHNyY0VuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgc3JjRW5kID0gdGhpcy5sZW5ndGhcbiAgfVxuXG4gIGlmIChzcmNTdGFydCA+PSB0aGlzLmxlbmd0aCkge1xuICAgIHJldHVybiBkc3QgfHwgQnVmZmVyLmFsbG9jKDApXG4gIH1cblxuICBpZiAoc3JjRW5kIDw9IDApIHtcbiAgICByZXR1cm4gZHN0IHx8IEJ1ZmZlci5hbGxvYygwKVxuICB9XG5cbiAgY29uc3QgY29weSA9ICEhZHN0XG4gIGNvbnN0IG9mZiA9IHRoaXMuX29mZnNldChzcmNTdGFydClcbiAgY29uc3QgbGVuID0gc3JjRW5kIC0gc3JjU3RhcnRcbiAgbGV0IGJ5dGVzID0gbGVuXG4gIGxldCBidWZvZmYgPSAoY29weSAmJiBkc3RTdGFydCkgfHwgMFxuICBsZXQgc3RhcnQgPSBvZmZbMV1cblxuICAvLyBjb3B5L3NsaWNlIGV2ZXJ5dGhpbmdcbiAgaWYgKHNyY1N0YXJ0ID09PSAwICYmIHNyY0VuZCA9PT0gdGhpcy5sZW5ndGgpIHtcbiAgICBpZiAoIWNvcHkpIHtcbiAgICAgIC8vIHNsaWNlLCBidXQgZnVsbCBjb25jYXQgaWYgbXVsdGlwbGUgYnVmZmVyc1xuICAgICAgcmV0dXJuIHRoaXMuX2J1ZnMubGVuZ3RoID09PSAxXG4gICAgICAgID8gdGhpcy5fYnVmc1swXVxuICAgICAgICA6IEJ1ZmZlci5jb25jYXQodGhpcy5fYnVmcywgdGhpcy5sZW5ndGgpXG4gICAgfVxuXG4gICAgLy8gY29weSwgbmVlZCB0byBjb3B5IGluZGl2aWR1YWwgYnVmZmVyc1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fYnVmcy5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy5fYnVmc1tpXS5jb3B5KGRzdCwgYnVmb2ZmKVxuICAgICAgYnVmb2ZmICs9IHRoaXMuX2J1ZnNbaV0ubGVuZ3RoXG4gICAgfVxuXG4gICAgcmV0dXJuIGRzdFxuICB9XG5cbiAgLy8gZWFzeSwgY2hlYXAgY2FzZSB3aGVyZSBpdCdzIGEgc3Vic2V0IG9mIG9uZSBvZiB0aGUgYnVmZmVyc1xuICBpZiAoYnl0ZXMgPD0gdGhpcy5fYnVmc1tvZmZbMF1dLmxlbmd0aCAtIHN0YXJ0KSB7XG4gICAgcmV0dXJuIGNvcHlcbiAgICAgID8gdGhpcy5fYnVmc1tvZmZbMF1dLmNvcHkoZHN0LCBkc3RTdGFydCwgc3RhcnQsIHN0YXJ0ICsgYnl0ZXMpXG4gICAgICA6IHRoaXMuX2J1ZnNbb2ZmWzBdXS5zbGljZShzdGFydCwgc3RhcnQgKyBieXRlcylcbiAgfVxuXG4gIGlmICghY29weSkge1xuICAgIC8vIGEgc2xpY2UsIHdlIG5lZWQgc29tZXRoaW5nIHRvIGNvcHkgaW4gdG9cbiAgICBkc3QgPSBCdWZmZXIuYWxsb2NVbnNhZmUobGVuKVxuICB9XG5cbiAgZm9yIChsZXQgaSA9IG9mZlswXTsgaSA8IHRoaXMuX2J1ZnMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBsID0gdGhpcy5fYnVmc1tpXS5sZW5ndGggLSBzdGFydFxuXG4gICAgaWYgKGJ5dGVzID4gbCkge1xuICAgICAgdGhpcy5fYnVmc1tpXS5jb3B5KGRzdCwgYnVmb2ZmLCBzdGFydClcbiAgICAgIGJ1Zm9mZiArPSBsXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2J1ZnNbaV0uY29weShkc3QsIGJ1Zm9mZiwgc3RhcnQsIHN0YXJ0ICsgYnl0ZXMpXG4gICAgICBidWZvZmYgKz0gbFxuICAgICAgYnJlYWtcbiAgICB9XG5cbiAgICBieXRlcyAtPSBsXG5cbiAgICBpZiAoc3RhcnQpIHtcbiAgICAgIHN0YXJ0ID0gMFxuICAgIH1cbiAgfVxuXG4gIC8vIHNhZmVndWFyZCBzbyB0aGF0IHdlIGRvbid0IHJldHVybiB1bmluaXRpYWxpemVkIG1lbW9yeVxuICBpZiAoZHN0Lmxlbmd0aCA+IGJ1Zm9mZikgcmV0dXJuIGRzdC5zbGljZSgwLCBidWZvZmYpXG5cbiAgcmV0dXJuIGRzdFxufVxuXG5CdWZmZXJMaXN0LnByb3RvdHlwZS5zaGFsbG93U2xpY2UgPSBmdW5jdGlvbiBzaGFsbG93U2xpY2UgKHN0YXJ0LCBlbmQpIHtcbiAgc3RhcnQgPSBzdGFydCB8fCAwXG4gIGVuZCA9IHR5cGVvZiBlbmQgIT09ICdudW1iZXInID8gdGhpcy5sZW5ndGggOiBlbmRcblxuICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgKz0gdGhpcy5sZW5ndGhcbiAgfVxuXG4gIGlmIChlbmQgPCAwKSB7XG4gICAgZW5kICs9IHRoaXMubGVuZ3RoXG4gIH1cblxuICBpZiAoc3RhcnQgPT09IGVuZCkge1xuICAgIHJldHVybiB0aGlzLl9uZXcoKVxuICB9XG5cbiAgY29uc3Qgc3RhcnRPZmZzZXQgPSB0aGlzLl9vZmZzZXQoc3RhcnQpXG4gIGNvbnN0IGVuZE9mZnNldCA9IHRoaXMuX29mZnNldChlbmQpXG4gIGNvbnN0IGJ1ZmZlcnMgPSB0aGlzLl9idWZzLnNsaWNlKHN0YXJ0T2Zmc2V0WzBdLCBlbmRPZmZzZXRbMF0gKyAxKVxuXG4gIGlmIChlbmRPZmZzZXRbMV0gPT09IDApIHtcbiAgICBidWZmZXJzLnBvcCgpXG4gIH0gZWxzZSB7XG4gICAgYnVmZmVyc1tidWZmZXJzLmxlbmd0aCAtIDFdID0gYnVmZmVyc1tidWZmZXJzLmxlbmd0aCAtIDFdLnNsaWNlKDAsIGVuZE9mZnNldFsxXSlcbiAgfVxuXG4gIGlmIChzdGFydE9mZnNldFsxXSAhPT0gMCkge1xuICAgIGJ1ZmZlcnNbMF0gPSBidWZmZXJzWzBdLnNsaWNlKHN0YXJ0T2Zmc2V0WzFdKVxuICB9XG5cbiAgcmV0dXJuIHRoaXMuX25ldyhidWZmZXJzKVxufVxuXG5CdWZmZXJMaXN0LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nIChlbmNvZGluZywgc3RhcnQsIGVuZCkge1xuICByZXR1cm4gdGhpcy5zbGljZShzdGFydCwgZW5kKS50b1N0cmluZyhlbmNvZGluZylcbn1cblxuQnVmZmVyTGlzdC5wcm90b3R5cGUuY29uc3VtZSA9IGZ1bmN0aW9uIGNvbnN1bWUgKGJ5dGVzKSB7XG4gIC8vIGZpcnN0LCBub3JtYWxpemUgdGhlIGFyZ3VtZW50LCBpbiBhY2NvcmRhbmNlIHdpdGggaG93IEJ1ZmZlciBkb2VzIGl0XG4gIGJ5dGVzID0gTWF0aC50cnVuYyhieXRlcylcbiAgLy8gZG8gbm90aGluZyBpZiBub3QgYSBwb3NpdGl2ZSBudW1iZXJcbiAgaWYgKE51bWJlci5pc05hTihieXRlcykgfHwgYnl0ZXMgPD0gMCkgcmV0dXJuIHRoaXNcblxuICB3aGlsZSAodGhpcy5fYnVmcy5sZW5ndGgpIHtcbiAgICBpZiAoYnl0ZXMgPj0gdGhpcy5fYnVmc1swXS5sZW5ndGgpIHtcbiAgICAgIGJ5dGVzIC09IHRoaXMuX2J1ZnNbMF0ubGVuZ3RoXG4gICAgICB0aGlzLmxlbmd0aCAtPSB0aGlzLl9idWZzWzBdLmxlbmd0aFxuICAgICAgdGhpcy5fYnVmcy5zaGlmdCgpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2J1ZnNbMF0gPSB0aGlzLl9idWZzWzBdLnNsaWNlKGJ5dGVzKVxuICAgICAgdGhpcy5sZW5ndGggLT0gYnl0ZXNcbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyTGlzdC5wcm90b3R5cGUuZHVwbGljYXRlID0gZnVuY3Rpb24gZHVwbGljYXRlICgpIHtcbiAgY29uc3QgY29weSA9IHRoaXMuX25ldygpXG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9idWZzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29weS5hcHBlbmQodGhpcy5fYnVmc1tpXSlcbiAgfVxuXG4gIHJldHVybiBjb3B5XG59XG5cbkJ1ZmZlckxpc3QucHJvdG90eXBlLmFwcGVuZCA9IGZ1bmN0aW9uIGFwcGVuZCAoYnVmKSB7XG4gIGlmIChidWYgPT0gbnVsbCkge1xuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBpZiAoYnVmLmJ1ZmZlcikge1xuICAgIC8vIGFwcGVuZCBhIHZpZXcgb2YgdGhlIHVuZGVybHlpbmcgQXJyYXlCdWZmZXJcbiAgICB0aGlzLl9hcHBlbmRCdWZmZXIoQnVmZmVyLmZyb20oYnVmLmJ1ZmZlciwgYnVmLmJ5dGVPZmZzZXQsIGJ1Zi5ieXRlTGVuZ3RoKSlcbiAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGJ1ZikpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJ1Zi5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy5hcHBlbmQoYnVmW2ldKVxuICAgIH1cbiAgfSBlbHNlIGlmICh0aGlzLl9pc0J1ZmZlckxpc3QoYnVmKSkge1xuICAgIC8vIHVud3JhcCBhcmd1bWVudCBpbnRvIGluZGl2aWR1YWwgQnVmZmVyTGlzdHNcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJ1Zi5fYnVmcy5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy5hcHBlbmQoYnVmLl9idWZzW2ldKVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBjb2VyY2UgbnVtYmVyIGFyZ3VtZW50cyB0byBzdHJpbmdzLCBzaW5jZSBCdWZmZXIobnVtYmVyKSBkb2VzXG4gICAgLy8gdW5pbml0aWFsaXplZCBtZW1vcnkgYWxsb2NhdGlvblxuICAgIGlmICh0eXBlb2YgYnVmID09PSAnbnVtYmVyJykge1xuICAgICAgYnVmID0gYnVmLnRvU3RyaW5nKClcbiAgICB9XG5cbiAgICB0aGlzLl9hcHBlbmRCdWZmZXIoQnVmZmVyLmZyb20oYnVmKSlcbiAgfVxuXG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlckxpc3QucHJvdG90eXBlLl9hcHBlbmRCdWZmZXIgPSBmdW5jdGlvbiBhcHBlbmRCdWZmZXIgKGJ1Zikge1xuICB0aGlzLl9idWZzLnB1c2goYnVmKVxuICB0aGlzLmxlbmd0aCArPSBidWYubGVuZ3RoXG59XG5cbkJ1ZmZlckxpc3QucHJvdG90eXBlLmluZGV4T2YgPSBmdW5jdGlvbiAoc2VhcmNoLCBvZmZzZXQsIGVuY29kaW5nKSB7XG4gIGlmIChlbmNvZGluZyA9PT0gdW5kZWZpbmVkICYmIHR5cGVvZiBvZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jb2RpbmcgPSBvZmZzZXRcbiAgICBvZmZzZXQgPSB1bmRlZmluZWRcbiAgfVxuXG4gIGlmICh0eXBlb2Ygc2VhcmNoID09PSAnZnVuY3Rpb24nIHx8IEFycmF5LmlzQXJyYXkoc2VhcmNoKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcInZhbHVlXCIgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBzdHJpbmcsIEJ1ZmZlciwgQnVmZmVyTGlzdCwgb3IgVWludDhBcnJheS4nKVxuICB9IGVsc2UgaWYgKHR5cGVvZiBzZWFyY2ggPT09ICdudW1iZXInKSB7XG4gICAgc2VhcmNoID0gQnVmZmVyLmZyb20oW3NlYXJjaF0pXG4gIH0gZWxzZSBpZiAodHlwZW9mIHNlYXJjaCA9PT0gJ3N0cmluZycpIHtcbiAgICBzZWFyY2ggPSBCdWZmZXIuZnJvbShzZWFyY2gsIGVuY29kaW5nKVxuICB9IGVsc2UgaWYgKHRoaXMuX2lzQnVmZmVyTGlzdChzZWFyY2gpKSB7XG4gICAgc2VhcmNoID0gc2VhcmNoLnNsaWNlKClcbiAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHNlYXJjaC5idWZmZXIpKSB7XG4gICAgc2VhcmNoID0gQnVmZmVyLmZyb20oc2VhcmNoLmJ1ZmZlciwgc2VhcmNoLmJ5dGVPZmZzZXQsIHNlYXJjaC5ieXRlTGVuZ3RoKVxuICB9IGVsc2UgaWYgKCFCdWZmZXIuaXNCdWZmZXIoc2VhcmNoKSkge1xuICAgIHNlYXJjaCA9IEJ1ZmZlci5mcm9tKHNlYXJjaClcbiAgfVxuXG4gIG9mZnNldCA9IE51bWJlcihvZmZzZXQgfHwgMClcblxuICBpZiAoaXNOYU4ob2Zmc2V0KSkge1xuICAgIG9mZnNldCA9IDBcbiAgfVxuXG4gIGlmIChvZmZzZXQgPCAwKSB7XG4gICAgb2Zmc2V0ID0gdGhpcy5sZW5ndGggKyBvZmZzZXRcbiAgfVxuXG4gIGlmIChvZmZzZXQgPCAwKSB7XG4gICAgb2Zmc2V0ID0gMFxuICB9XG5cbiAgaWYgKHNlYXJjaC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gb2Zmc2V0ID4gdGhpcy5sZW5ndGggPyB0aGlzLmxlbmd0aCA6IG9mZnNldFxuICB9XG5cbiAgY29uc3QgYmxPZmZzZXQgPSB0aGlzLl9vZmZzZXQob2Zmc2V0KVxuICBsZXQgYmxJbmRleCA9IGJsT2Zmc2V0WzBdIC8vIGluZGV4IG9mIHdoaWNoIGludGVybmFsIGJ1ZmZlciB3ZSdyZSB3b3JraW5nIG9uXG4gIGxldCBidWZmT2Zmc2V0ID0gYmxPZmZzZXRbMV0gLy8gb2Zmc2V0IG9mIHRoZSBpbnRlcm5hbCBidWZmZXIgd2UncmUgd29ya2luZyBvblxuXG4gIC8vIHNjYW4gb3ZlciBlYWNoIGJ1ZmZlclxuICBmb3IgKDsgYmxJbmRleCA8IHRoaXMuX2J1ZnMubGVuZ3RoOyBibEluZGV4KyspIHtcbiAgICBjb25zdCBidWZmID0gdGhpcy5fYnVmc1tibEluZGV4XVxuXG4gICAgd2hpbGUgKGJ1ZmZPZmZzZXQgPCBidWZmLmxlbmd0aCkge1xuICAgICAgY29uc3QgYXZhaWxhYmxlV2luZG93ID0gYnVmZi5sZW5ndGggLSBidWZmT2Zmc2V0XG5cbiAgICAgIGlmIChhdmFpbGFibGVXaW5kb3cgPj0gc2VhcmNoLmxlbmd0aCkge1xuICAgICAgICBjb25zdCBuYXRpdmVTZWFyY2hSZXN1bHQgPSBidWZmLmluZGV4T2Yoc2VhcmNoLCBidWZmT2Zmc2V0KVxuXG4gICAgICAgIGlmIChuYXRpdmVTZWFyY2hSZXN1bHQgIT09IC0xKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX3JldmVyc2VPZmZzZXQoW2JsSW5kZXgsIG5hdGl2ZVNlYXJjaFJlc3VsdF0pXG4gICAgICAgIH1cblxuICAgICAgICBidWZmT2Zmc2V0ID0gYnVmZi5sZW5ndGggLSBzZWFyY2gubGVuZ3RoICsgMSAvLyBlbmQgb2YgbmF0aXZlIHNlYXJjaCB3aW5kb3dcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHJldk9mZnNldCA9IHRoaXMuX3JldmVyc2VPZmZzZXQoW2JsSW5kZXgsIGJ1ZmZPZmZzZXRdKVxuXG4gICAgICAgIGlmICh0aGlzLl9tYXRjaChyZXZPZmZzZXQsIHNlYXJjaCkpIHtcbiAgICAgICAgICByZXR1cm4gcmV2T2Zmc2V0XG4gICAgICAgIH1cblxuICAgICAgICBidWZmT2Zmc2V0KytcbiAgICAgIH1cbiAgICB9XG5cbiAgICBidWZmT2Zmc2V0ID0gMFxuICB9XG5cbiAgcmV0dXJuIC0xXG59XG5cbkJ1ZmZlckxpc3QucHJvdG90eXBlLl9tYXRjaCA9IGZ1bmN0aW9uIChvZmZzZXQsIHNlYXJjaCkge1xuICBpZiAodGhpcy5sZW5ndGggLSBvZmZzZXQgPCBzZWFyY2gubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICBmb3IgKGxldCBzZWFyY2hPZmZzZXQgPSAwOyBzZWFyY2hPZmZzZXQgPCBzZWFyY2gubGVuZ3RoOyBzZWFyY2hPZmZzZXQrKykge1xuICAgIGlmICh0aGlzLmdldChvZmZzZXQgKyBzZWFyY2hPZmZzZXQpICE9PSBzZWFyY2hbc2VhcmNoT2Zmc2V0XSkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlXG59XG5cbjsoZnVuY3Rpb24gKCkge1xuICBjb25zdCBtZXRob2RzID0ge1xuICAgIHJlYWREb3VibGVCRTogOCxcbiAgICByZWFkRG91YmxlTEU6IDgsXG4gICAgcmVhZEZsb2F0QkU6IDQsXG4gICAgcmVhZEZsb2F0TEU6IDQsXG4gICAgcmVhZEludDMyQkU6IDQsXG4gICAgcmVhZEludDMyTEU6IDQsXG4gICAgcmVhZFVJbnQzMkJFOiA0LFxuICAgIHJlYWRVSW50MzJMRTogNCxcbiAgICByZWFkSW50MTZCRTogMixcbiAgICByZWFkSW50MTZMRTogMixcbiAgICByZWFkVUludDE2QkU6IDIsXG4gICAgcmVhZFVJbnQxNkxFOiAyLFxuICAgIHJlYWRJbnQ4OiAxLFxuICAgIHJlYWRVSW50ODogMSxcbiAgICByZWFkSW50QkU6IG51bGwsXG4gICAgcmVhZEludExFOiBudWxsLFxuICAgIHJlYWRVSW50QkU6IG51bGwsXG4gICAgcmVhZFVJbnRMRTogbnVsbFxuICB9XG5cbiAgZm9yIChjb25zdCBtIGluIG1ldGhvZHMpIHtcbiAgICAoZnVuY3Rpb24gKG0pIHtcbiAgICAgIGlmIChtZXRob2RzW21dID09PSBudWxsKSB7XG4gICAgICAgIEJ1ZmZlckxpc3QucHJvdG90eXBlW21dID0gZnVuY3Rpb24gKG9mZnNldCwgYnl0ZUxlbmd0aCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgYnl0ZUxlbmd0aClbbV0oMCwgYnl0ZUxlbmd0aClcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgQnVmZmVyTGlzdC5wcm90b3R5cGVbbV0gPSBmdW5jdGlvbiAob2Zmc2V0ID0gMCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgbWV0aG9kc1ttXSlbbV0oMClcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0obSkpXG4gIH1cbn0oKSlcblxuLy8gVXNlZCBpbnRlcm5hbGx5IGJ5IHRoZSBjbGFzcyBhbmQgYWxzbyBhcyBhbiBpbmRpY2F0b3Igb2YgdGhpcyBvYmplY3QgYmVpbmdcbi8vIGEgYEJ1ZmZlckxpc3RgLiBJdCdzIG5vdCBwb3NzaWJsZSB0byB1c2UgYGluc3RhbmNlb2YgQnVmZmVyTGlzdGAgaW4gYSBicm93c2VyXG4vLyBlbnZpcm9ubWVudCBiZWNhdXNlIHRoZXJlIGNvdWxkIGJlIG11bHRpcGxlIGRpZmZlcmVudCBjb3BpZXMgb2YgdGhlXG4vLyBCdWZmZXJMaXN0IGNsYXNzIGFuZCBzb21lIGBCdWZmZXJMaXN0YHMgbWlnaHQgYmUgYEJ1ZmZlckxpc3Rgcy5cbkJ1ZmZlckxpc3QucHJvdG90eXBlLl9pc0J1ZmZlckxpc3QgPSBmdW5jdGlvbiBfaXNCdWZmZXJMaXN0IChiKSB7XG4gIHJldHVybiBiIGluc3RhbmNlb2YgQnVmZmVyTGlzdCB8fCBCdWZmZXJMaXN0LmlzQnVmZmVyTGlzdChiKVxufVxuXG5CdWZmZXJMaXN0LmlzQnVmZmVyTGlzdCA9IGZ1bmN0aW9uIGlzQnVmZmVyTGlzdCAoYikge1xuICByZXR1cm4gYiAhPSBudWxsICYmIGJbc3ltYm9sXVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEJ1ZmZlckxpc3RcbiJdLCJuYW1lcyI6WyJCdWZmZXIiLCJyZXF1aXJlIiwic3ltYm9sIiwiU3ltYm9sIiwiZm9yIiwiQnVmZmVyTGlzdCIsImJ1ZiIsIl9pbml0IiwiY2FsbCIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwidmFsdWUiLCJfYnVmcyIsImxlbmd0aCIsImFwcGVuZCIsInByb3RvdHlwZSIsIl9uZXciLCJfb2Zmc2V0Iiwib2Zmc2V0IiwidG90IiwiaSIsIl90IiwiX3JldmVyc2VPZmZzZXQiLCJibE9mZnNldCIsImJ1ZmZlcklkIiwiZ2V0IiwiaW5kZXgiLCJ1bmRlZmluZWQiLCJzbGljZSIsInN0YXJ0IiwiZW5kIiwiY29weSIsImRzdCIsImRzdFN0YXJ0Iiwic3JjU3RhcnQiLCJzcmNFbmQiLCJhbGxvYyIsIm9mZiIsImxlbiIsImJ5dGVzIiwiYnVmb2ZmIiwiY29uY2F0IiwiYWxsb2NVbnNhZmUiLCJsIiwic2hhbGxvd1NsaWNlIiwic3RhcnRPZmZzZXQiLCJlbmRPZmZzZXQiLCJidWZmZXJzIiwicG9wIiwidG9TdHJpbmciLCJlbmNvZGluZyIsImNvbnN1bWUiLCJNYXRoIiwidHJ1bmMiLCJOdW1iZXIiLCJpc05hTiIsInNoaWZ0IiwiZHVwbGljYXRlIiwiYnVmZmVyIiwiX2FwcGVuZEJ1ZmZlciIsImZyb20iLCJieXRlT2Zmc2V0IiwiYnl0ZUxlbmd0aCIsIkFycmF5IiwiaXNBcnJheSIsIl9pc0J1ZmZlckxpc3QiLCJhcHBlbmRCdWZmZXIiLCJwdXNoIiwiaW5kZXhPZiIsInNlYXJjaCIsIlR5cGVFcnJvciIsImlzQnVmZmVyIiwiYmxJbmRleCIsImJ1ZmZPZmZzZXQiLCJidWZmIiwiYXZhaWxhYmxlV2luZG93IiwibmF0aXZlU2VhcmNoUmVzdWx0IiwicmV2T2Zmc2V0IiwiX21hdGNoIiwic2VhcmNoT2Zmc2V0IiwibWV0aG9kcyIsInJlYWREb3VibGVCRSIsInJlYWREb3VibGVMRSIsInJlYWRGbG9hdEJFIiwicmVhZEZsb2F0TEUiLCJyZWFkSW50MzJCRSIsInJlYWRJbnQzMkxFIiwicmVhZFVJbnQzMkJFIiwicmVhZFVJbnQzMkxFIiwicmVhZEludDE2QkUiLCJyZWFkSW50MTZMRSIsInJlYWRVSW50MTZCRSIsInJlYWRVSW50MTZMRSIsInJlYWRJbnQ4IiwicmVhZFVJbnQ4IiwicmVhZEludEJFIiwicmVhZEludExFIiwicmVhZFVJbnRCRSIsInJlYWRVSW50TEUiLCJtIiwiYiIsImlzQnVmZmVyTGlzdCIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bl/BufferList.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/bl/bl.js":
/*!*******************************!*\
  !*** ./node_modules/bl/bl.js ***!
  \*******************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst DuplexStream = (__webpack_require__(/*! readable-stream */ \"(rsc)/./node_modules/readable-stream/readable.js\").Duplex);\nconst inherits = __webpack_require__(/*! inherits */ \"(rsc)/./node_modules/inherits/inherits.js\");\nconst BufferList = __webpack_require__(/*! ./BufferList */ \"(rsc)/./node_modules/bl/BufferList.js\");\nfunction BufferListStream(callback) {\n    if (!(this instanceof BufferListStream)) {\n        return new BufferListStream(callback);\n    }\n    if (typeof callback === \"function\") {\n        this._callback = callback;\n        const piper = (function piper(err) {\n            if (this._callback) {\n                this._callback(err);\n                this._callback = null;\n            }\n        }).bind(this);\n        this.on(\"pipe\", function onPipe(src) {\n            src.on(\"error\", piper);\n        });\n        this.on(\"unpipe\", function onUnpipe(src) {\n            src.removeListener(\"error\", piper);\n        });\n        callback = null;\n    }\n    BufferList._init.call(this, callback);\n    DuplexStream.call(this);\n}\ninherits(BufferListStream, DuplexStream);\nObject.assign(BufferListStream.prototype, BufferList.prototype);\nBufferListStream.prototype._new = function _new(callback) {\n    return new BufferListStream(callback);\n};\nBufferListStream.prototype._write = function _write(buf, encoding, callback) {\n    this._appendBuffer(buf);\n    if (typeof callback === \"function\") {\n        callback();\n    }\n};\nBufferListStream.prototype._read = function _read(size) {\n    if (!this.length) {\n        return this.push(null);\n    }\n    size = Math.min(size, this.length);\n    this.push(this.slice(0, size));\n    this.consume(size);\n};\nBufferListStream.prototype.end = function end(chunk) {\n    DuplexStream.prototype.end.call(this, chunk);\n    if (this._callback) {\n        this._callback(null, this.slice());\n        this._callback = null;\n    }\n};\nBufferListStream.prototype._destroy = function _destroy(err, cb) {\n    this._bufs.length = 0;\n    this.length = 0;\n    cb(err);\n};\nBufferListStream.prototype._isBufferList = function _isBufferList(b) {\n    return b instanceof BufferListStream || b instanceof BufferList || BufferListStream.isBufferList(b);\n};\nBufferListStream.isBufferList = BufferList.isBufferList;\nmodule.exports = BufferListStream;\nmodule.exports.BufferListStream = BufferListStream;\nmodule.exports.BufferList = BufferList;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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aUJBQWlCb0MsWUFBWSxHQUFHckMsV0FBV3FDLFlBQVk7QUFFdkRDLE9BQU9DLE9BQU8sR0FBR3RDO0FBQ2pCcUMsK0JBQStCLEdBQUdyQztBQUNsQ3FDLHlCQUF5QixHQUFHdEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90aW1lc2hlZXQtcHJvY2Vzc29yLy4vbm9kZV9tb2R1bGVzL2JsL2JsLmpzPzM5MDIiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IER1cGxleFN0cmVhbSA9IHJlcXVpcmUoJ3JlYWRhYmxlLXN0cmVhbScpLkR1cGxleFxuY29uc3QgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG5jb25zdCBCdWZmZXJMaXN0ID0gcmVxdWlyZSgnLi9CdWZmZXJMaXN0JylcblxuZnVuY3Rpb24gQnVmZmVyTGlzdFN0cmVhbSAoY2FsbGJhY2spIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEJ1ZmZlckxpc3RTdHJlYW0pKSB7XG4gICAgcmV0dXJuIG5ldyBCdWZmZXJMaXN0U3RyZWFtKGNhbGxiYWNrKVxuICB9XG5cbiAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHRoaXMuX2NhbGxiYWNrID0gY2FsbGJhY2tcblxuICAgIGNvbnN0IHBpcGVyID0gZnVuY3Rpb24gcGlwZXIgKGVycikge1xuICAgICAgaWYgKHRoaXMuX2NhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMuX2NhbGxiYWNrKGVycilcbiAgICAgICAgdGhpcy5fY2FsbGJhY2sgPSBudWxsXG4gICAgICB9XG4gICAgfS5iaW5kKHRoaXMpXG5cbiAgICB0aGlzLm9uKCdwaXBlJywgZnVuY3Rpb24gb25QaXBlIChzcmMpIHtcbiAgICAgIHNyYy5vbignZXJyb3InLCBwaXBlcilcbiAgICB9KVxuICAgIHRoaXMub24oJ3VucGlwZScsIGZ1bmN0aW9uIG9uVW5waXBlIChzcmMpIHtcbiAgICAgIHNyYy5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBwaXBlcilcbiAgICB9KVxuXG4gICAgY2FsbGJhY2sgPSBudWxsXG4gIH1cblxuICBCdWZmZXJMaXN0Ll9pbml0LmNhbGwodGhpcywgY2FsbGJhY2spXG4gIER1cGxleFN0cmVhbS5jYWxsKHRoaXMpXG59XG5cbmluaGVyaXRzKEJ1ZmZlckxpc3RTdHJlYW0sIER1cGxleFN0cmVhbSlcbk9iamVjdC5hc3NpZ24oQnVmZmVyTGlzdFN0cmVhbS5wcm90b3R5cGUsIEJ1ZmZlckxpc3QucHJvdG90eXBlKVxuXG5CdWZmZXJMaXN0U3RyZWFtLnByb3RvdHlwZS5fbmV3ID0gZnVuY3Rpb24gX25ldyAoY2FsbGJhY2spIHtcbiAgcmV0dXJuIG5ldyBCdWZmZXJMaXN0U3RyZWFtKGNhbGxiYWNrKVxufVxuXG5CdWZmZXJMaXN0U3RyZWFtLnByb3RvdHlwZS5fd3JpdGUgPSBmdW5jdGlvbiBfd3JpdGUgKGJ1ZiwgZW5jb2RpbmcsIGNhbGxiYWNrKSB7XG4gIHRoaXMuX2FwcGVuZEJ1ZmZlcihidWYpXG5cbiAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrKClcbiAgfVxufVxuXG5CdWZmZXJMaXN0U3RyZWFtLnByb3RvdHlwZS5fcmVhZCA9IGZ1bmN0aW9uIF9yZWFkIChzaXplKSB7XG4gIGlmICghdGhpcy5sZW5ndGgpIHtcbiAgICByZXR1cm4gdGhpcy5wdXNoKG51bGwpXG4gIH1cblxuICBzaXplID0gTWF0aC5taW4oc2l6ZSwgdGhpcy5sZW5ndGgpXG4gIHRoaXMucHVzaCh0aGlzLnNsaWNlKDAsIHNpemUpKVxuICB0aGlzLmNvbnN1bWUoc2l6ZSlcbn1cblxuQnVmZmVyTGlzdFN0cmVhbS5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24gZW5kIChjaHVuaykge1xuICBEdXBsZXhTdHJlYW0ucHJvdG90eXBlLmVuZC5jYWxsKHRoaXMsIGNodW5rKVxuXG4gIGlmICh0aGlzLl9jYWxsYmFjaykge1xuICAgIHRoaXMuX2NhbGxiYWNrKG51bGwsIHRoaXMuc2xpY2UoKSlcbiAgICB0aGlzLl9jYWxsYmFjayA9IG51bGxcbiAgfVxufVxuXG5CdWZmZXJMaXN0U3RyZWFtLnByb3RvdHlwZS5fZGVzdHJveSA9IGZ1bmN0aW9uIF9kZXN0cm95IChlcnIsIGNiKSB7XG4gIHRoaXMuX2J1ZnMubGVuZ3RoID0gMFxuICB0aGlzLmxlbmd0aCA9IDBcbiAgY2IoZXJyKVxufVxuXG5CdWZmZXJMaXN0U3RyZWFtLnByb3RvdHlwZS5faXNCdWZmZXJMaXN0ID0gZnVuY3Rpb24gX2lzQnVmZmVyTGlzdCAoYikge1xuICByZXR1cm4gYiBpbnN0YW5jZW9mIEJ1ZmZlckxpc3RTdHJlYW0gfHwgYiBpbnN0YW5jZW9mIEJ1ZmZlckxpc3QgfHwgQnVmZmVyTGlzdFN0cmVhbS5pc0J1ZmZlckxpc3QoYilcbn1cblxuQnVmZmVyTGlzdFN0cmVhbS5pc0J1ZmZlckxpc3QgPSBCdWZmZXJMaXN0LmlzQnVmZmVyTGlzdFxuXG5tb2R1bGUuZXhwb3J0cyA9IEJ1ZmZlckxpc3RTdHJlYW1cbm1vZHVsZS5leHBvcnRzLkJ1ZmZlckxpc3RTdHJlYW0gPSBCdWZmZXJMaXN0U3RyZWFtXG5tb2R1bGUuZXhwb3J0cy5CdWZmZXJMaXN0ID0gQnVmZmVyTGlzdFxuIl0sIm5hbWVzIjpbIkR1cGxleFN0cmVhbSIsInJlcXVpcmUiLCJEdXBsZXgiLCJpbmhlcml0cyIsIkJ1ZmZlckxpc3QiLCJCdWZmZXJMaXN0U3RyZWFtIiwiY2FsbGJhY2siLCJfY2FsbGJhY2siLCJwaXBlciIsImVyciIsImJpbmQiLCJvbiIsIm9uUGlwZSIsInNyYyIsIm9uVW5waXBlIiwicmVtb3ZlTGlzdGVuZXIiLCJfaW5pdCIsImNhbGwiLCJPYmplY3QiLCJhc3NpZ24iLCJwcm90b3R5cGUiLCJfbmV3IiwiX3dyaXRlIiwiYnVmIiwiZW5jb2RpbmciLCJfYXBwZW5kQnVmZmVyIiwiX3JlYWQiLCJzaXplIiwibGVuZ3RoIiwicHVzaCIsIk1hdGgiLCJtaW4iLCJzbGljZSIsImNvbnN1bWUiLCJlbmQiLCJjaHVuayIsIl9kZXN0cm95IiwiY2IiLCJfYnVmcyIsIl9pc0J1ZmZlckxpc3QiLCJiIiwiaXNCdWZmZXJMaXN0IiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/bl/bl.js\n");

/***/ })

};
;